<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浙里办H5接入爬坑</title>
      <link href="/posts/a6b9.html"/>
      <url>/posts/a6b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录个人遇到的-h5应用接入’浙里办’-的爬坑之路！"><a href="#记录个人遇到的-h5应用接入’浙里办’-的爬坑之路！" class="headerlink" title="记录个人遇到的 h5应用接入’浙里办’ 的爬坑之路！"></a>记录个人遇到的 h5应用接入’浙里办’ 的爬坑之路！</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近接到一个公司之前使用vue2.0  vue-cli2搭建的一个H5项目，现在要求接入到 浙里办APP、浙里办-支付宝小程序。说难吧 刚开始可能由于该项目的经理没有讲的太清除，导致我和后端哥们二脸懵逼！！！<br>就简单告诉我们app改造接入浙里办，然后群发了 语雀(<a href="https://odynww.yuque.com/docs/share/525e3e8a-ad52-421b-90da-2d76808e3050?#DB3a8">https://odynww.yuque.com/docs/share/525e3e8a-ad52-421b-90da-2d76808e3050?#DB3a8</a>) 这篇文档。  也没和我们讲’浙里办’是什么？之前的app是干嘛用的！对于没接触过这个方向的同学来说简直是懵逼和无奈，直接阅读这么长一篇文档的话那就是浪费很多时间。 无从下手的我们只能先请教了之前接触过的项目经理给我们大致讲了讲流程才大致明白了。接下来在开发过程中发现要注意的东西还是挺多的，踩了很多坑，特以此篇记录，也为能帮助到初次接触这方面的同学。</p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p>这里我主要讲我前端开发中遇到的问题，以及我个人的一些理解。</p><h3 id="1-文档阅读"><a href="#1-文档阅读" class="headerlink" title="1.文档阅读"></a>1.文档阅读</h3><p>拿到技术对接浙里办的文档时，一定要多阅读几遍！！！因为第一次接触这方面，内容也多，理解能力不是特别强的没几遍还真整不明白。整个文档内容基本了解以后就可以专注前端开发部分了。</p><h3 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h3><p>首先问项目负责人要文档中说的 应用开发管理平台相关账号，这个平台也就是浙里办的应用中台。我们的h5应用开发完打包后需要上传到这个平台，然后测试、发布上线。<br>我们应用一部分内容需要调用浙里办的JSBridge API调用原生功能。所以需要官网提供的debug工具后续接口调试用到。</p><h3 id="3-单点登录"><a href="#3-单点登录" class="headerlink" title="3.单点登录"></a>3.单点登录</h3><p>浙里办是硬性要求用户数据都是要走他那边的登录的，针对这个要求，前需要把登录操作的页面跳转直接改为浙里办提供的登录地址。<em>参考文档 1.1.7.3 个人登录</em><br>首先单点登录分为：个人用户的单点登录和法人用户的单点登录。我这里只做了个人用户登录。<br>个人登录又分为：浙里办app环境登录 和 浙里办-支付宝小程序环境登录。<br><em>环境判断见文档：1.1.7.1.浙里办APP、支付宝-浙里办小程序的判断代码</em></p><p>⭐⭐⭐个人登录注意点：<br>需要用到接入码、这个接入码也是找项目负责人由甲方配置提供；goto跳转地址就是我们前端应用的首页，这个地址需要提供给甲方让他们配置好。<br>这样我们就按照文档拼接成了一个登录的跳转地址。<br>等他们把跳转地址配置完之后，用户操作一个涉及到用户读取却没有登录的地方时，就跳转到了浙里办的登录页面地址，然后输入自己的账号密码点击登录，这时候登录成功后页面会自动的跳转到你在第二部分goto设置的回调地址上，也就是我们h5应用的（一般为）首页。<br>在跳回来的过程中会在 URL 路径上带有登录时返回给你的 ticket 等参数，此时前端需要从url里取出这个标识传给后端进行①票据认证 ②票据认证完会返回一个token 这时就可以拿这个token 获取到用户信息了。 为了简洁操作 这里我们做的时候直接把ticket传给服务端，服务端处理完 直接把用户信息返回给了我客户端。</p><h3 id="4-埋点"><a href="#4-埋点" class="headerlink" title="4.埋点"></a>4.埋点</h3><p>这里要吐槽一下他们提供的文档了，怎么埋点文档应该是写的可以看得懂，主要是没有说明白如何测试埋点，如何判断埋点是否成功，我在初次接触这块的时候还是在网上查找了大量资料完成。<br>基础埋点如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> d<span class="token punctuation">,</span> s<span class="token punctuation">,</span> q<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    w<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> f <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>j <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'beacon-aplus'</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'https://alidt.alicdn.com/alilog/mlog/aplus_cloud.js'</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">,</span> <span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token string">'aplus_queue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'aplus-rhost-v'</span><span class="token punctuation">,</span> <span class="token string">'alog.zjzwfw.gov.cn'</span><span class="token punctuation">]</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'aplus-rhost-g'</span><span class="token punctuation">,</span> <span class="token string">'alog.zjzwfw.gov.cn'</span><span class="token punctuation">]</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> u <span class="token operator">=</span> navigator<span class="token punctuation">.</span>userAgent  <span class="token keyword">var</span> isAndroid <span class="token operator">=</span> u<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'Android'</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token keyword">var</span> isIOS <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>u<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span><span class="token punctuation">)</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'appId'</span><span class="token punctuation">,</span> <span class="token string">'your appid'</span><span class="token punctuation">]</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他pv\uv相关埋点建议写成单独js文件需要的埋点的页面引入，在vue项目里直接写到vue实例里可能导致埋点不成功。</p><h3 id="5-接口调试"><a href="#5-接口调试" class="headerlink" title="5.接口调试"></a>5.接口调试</h3><p>调试JSBridge API时，就需要用到上面提到的debug工具。调试的过程中手机浙里办app 需要全程在线才能一直连接调试、屏幕熄灭也会断开。<br>所有关于浙里办的 JSBridge API 的原生访问接口都需在真机上测试，浏览器是不行的！c通过登录浙里办app 应用平台上传测试版本生成的二维码，可以查看效果。在扫码之前确定项目里引入了JSBridge API 资源。</p><h3 id="6-支付宝小程序测试问题"><a href="#6-支付宝小程序测试问题" class="headerlink" title="6.支付宝小程序测试问题"></a>6.支付宝小程序测试问题</h3><p>应用管理平台发布上线后生成的访问地址二维码是给浙里办APP用的！！！支付宝扫码访问需要自己去转换：（<a href="https://3pwls.csb.app/）">https://3pwls.csb.app/）</a> 在这个网页中输入你浙里办预览二维码的网址，然后转换成支付宝能识别的二维码就可以在支付宝中看效果了。<br>原理：其实就是浙里办的支付宝小程序内嵌了一个浏览器，用这个内嵌的浏览器就可以调用浙里办的JSBridge了。</p><h3 id="7-打包发布"><a href="#7-打包发布" class="headerlink" title="7.打包发布"></a>7.打包发布</h3><p>前端应用不需要打包，只需要将项目src static index.html package.json gbc.json .postcssrc.js .babelrc 等资源依赖压缩为.zip的包 且不能大于40M,然后上传到 政务中台应用管理等编译通过后就生产二维码和链接可以查看测试版本了。<br>⭐⭐⭐这里我遇到了一个大坑！！！ 之前其他前端开发好的h5应用使用的图片有部分是中文命名，结果windows系统打包zip压缩后中文乱码了，导致上传应用平台编译失败，而Mac系统打包不会乱码！</p><!-- ### 8.申请上架 --><!-- 上架也挺繁琐，需要对照文档准备好相关材料，缺一不可，给到对应的负责人。所有流程走完审批通过了才会上架成功 --><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然开始是懵逼和无奈的，过程是崎岖和痛苦的，但是完成的那一刻心里还是挺开心的！东西没多难，但是我觉得初次接触一个新事物、新项目的时候还是得先整明白 是什么？干什么？完成什么？ 只有清楚这些才能理清思路和步骤然后再去进阶完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> H5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-study</title>
      <link href="/posts/8d7.html"/>
      <url>/posts/8d7.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue3-x-开始"><a href="#vue3-x-开始" class="headerlink" title="vue3.x 开始"></a>vue3.x 开始</h2><p>2020年 9.18发布3.0版本、代号： One Piece (海贼王)，耗时两年，2600+提交，99位贡献者。</p><h2 id="vue2-x-面临的问题"><a href="#vue2-x-面临的问题" class="headerlink" title="vue2.x 面临的问题"></a>vue2.x 面临的问题</h2><p>vue2.x版本发布于数年前，基于es5的技术架构，受限于当时通用浏览器的版本问题，在某些功能方面做了一些妥协：</p><ul><li>监听数据的方法<code>Object.definePerproty</code>, 不能对Object类型做深度监听。而为了深度监听，以及为了达到目的所要付出的代价，也就是<strong>递归遍历</strong>侦听数据</li><li><code>optionsApi</code>存在问题，功能分块混乱，我们需要把逻辑分别散落在<code>data，methods、computed</code>对象里，新增一个需求就需要分别在各项里修改，来回滚动</li><li>vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行</li><li>ts支持不友好<h2 id="vue3带来了什么？"><a href="#vue3带来了什么？" class="headerlink" title="vue3带来了什么？"></a>vue3带来了什么？</h2>打包大小减少41%、初次渲染快55%、更新渲染快133%、内存减少54%。<h2 id="Vue3-0-是如何变快的？"><a href="#Vue3-0-是如何变快的？" class="headerlink" title="Vue3.0 是如何变快的？"></a>Vue3.0 是如何变快的？</h2><ul><li>重构响应式系统，使用<code>Proxy</code>代理+ <code>Reflect</code>反射，替换<code>Object.defineProperty</code><br>使用Proxy代理优势：<br>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样递归遍历每个属性，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>直接实现对象属性的新增/删除 等</li><li>新增<code>Composition API</code>更好的逻辑复用和代码组织<br>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。<br><code>Composition Api</code>的出现，主要是也是为了解决Option API带来的问题<br>第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。<br>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</li><li>重构<code>Virtual DOM</code><br>Vue2 中的虚拟dom 是进行全量对比<br>Vue3 新增静态标记，模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li></ul></li></ul><h2 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h2><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。<br>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。<br>使用SSR的好处：</p><ul><li>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</li><li>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。<h2 id="Vue3-x搭建起步"><a href="#Vue3-x搭建起步" class="headerlink" title="Vue3.x搭建起步"></a>Vue3.x搭建起步</h2>安装好vue-cli后， 终端输入vue -V  出现4.5.x以上版本为3.x的脚手架。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">使用脚手架创建第一个3.x项目：Vue create vue3demo01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>Vite</code>创建项目:</p><pre class="line-numbers language-bash"><code class="language-bash">全局安装vite：<span class="token function">npm</span> <span class="token function">install</span> -g create-vite-app创建项目create-vite-app yourProjectName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>npm:<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> init @vitejs/app  按照提示操作or<span class="token function">npm</span> init @vitejs/app my-vue-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>yarn:<pre class="line-numbers language-bash"><code class="language-bash">yarn create @vitejs/app  按照提示操作oryarn create @vitejs/app my-vue-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>你还可以通过附加的命令行选项直接指定项目名称和你想要使用的模板</li></ul><pre class="line-numbers language-bash"><code class="language-bash">例如，要构建一个 Vite + Vue 项目运行:yarn create @vitejs/app my-vue-app --template vue例如创建 vue+ts：yarn create @vitejs/app my-vue-app --template vue-ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts入门</title>
      <link href="/posts/4d03.html"/>
      <url>/posts/4d03.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是typeScript"><a href="#什么是typeScript" class="headerlink" title="什么是typeScript?"></a>什么是typeScript?</h1><p>官方网站的定义是:TypeScript 是 js 类型的超集。简单说你可以将 TypeScript 看作是 JavaScript 之上的一个外壳。<br>TypeScript 是一个外壳，因为编写 TypeScript 的代码，在编译之后，，剩下的只是简单的 js 代码。<br>但是 JS 引擎无法读取 TypeScript 代码，因此任何 TypeScript 文件都应该经过预翻译过程，即编译。只有在第一个编译步骤之后，才剩下纯 JS 代码，可以在浏览器中运行。<br>Ps: 浏览器只能运行js、无法直接运行ts，因此需要ts编译js后运行。</p><pre class="line-numbers language-bash"><code class="language-bash">全局安装<span class="token function">npm</span> i -g typescript查看版本tsc -v运行tstsc xxx.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开发运行环境"><a href="#开发运行环境" class="headerlink" title="开发运行环境"></a>开发运行环境</h2><p><strong>因为ts代码不能直接在node里运行 需要先编译为js再执行</strong></p><ul><li>运行方式1：<pre class="line-numbers language-bash"><code class="language-bash">tsc  a.ts  <span class="token operator">=</span><span class="token operator">></span> 编译为 a.jsnode  a.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>运行方式2：<br>如上操作每次执行很麻烦，  (这个依赖包会在内部把ts编译为js，不再输出js文件)<pre class="line-numbers language-bash"><code class="language-bash">全局安装<span class="token function">npm</span> i -g ts-node查看版本好ts-node -v直接运行ts-node xxx.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vscode里配置自动编译ts为js"><a href="#vscode里配置自动编译ts为js" class="headerlink" title="vscode里配置自动编译ts为js"></a>vscode里配置自动编译ts为js</h2>vsCode  新建ts文件 –&gt; ts文件目录cmd，初始化 tsc –init，生成一个tsconfig.json文件 –&gt; 修改tsconfig.json文件的 “outDir”: “./js”,  ./js为要生成的文件夹 –&gt;点击vsCode终端 》点击运行任务》点击选择typescript 》点击选择监视typescript </li></ul><p>好处：没事修改ts文件不会像方法一每次在控制台输入tsc index.js，这个是自动的方式<br>tsc –init  生成配置文件 做以下修改</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">"outDir": "./js" // 把ts编译后放js文件夹下"strict": false //改为不严格模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该目录终端-运行任务-所有任务-tsc监视  <strong>ps:这里目录不能有&amp;符号会报错</strong><br>修改配置文件后执行指定文件 tsc 不生效。 要执行tsc</p><h2 id="ts里的一些概念"><a href="#ts里的一些概念" class="headerlink" title="ts里的一些概念"></a>ts里的一些概念</h2><ul><li><p>类型注解？<br><strong>是一种轻量级的为函数或者变量添加的约束</strong></p><pre class="line-numbers language-javaScript"><code class="language-javaScript">function test (str: string) &#123;return 'hell------' + str&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>隐式类型推断？</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">let age = 18 //   我们赋值变量数字18， 那么这个变量ts会推断为number类型// age ='qweq'   // 语法不允许let name // 如，我们声明变量name 没有赋值，ts无法推断当前变量类型 默认为any类型name = 18name = true// ps: 虽然ts会做隐式类型推断， 但是建议为每个变量明确类型，便于后期更直观的理解代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类型断言？<br><strong>在有些特殊情况下，ts无法推断出一个变量的具体类型，而我们开发者根据代码的使用情况知道这个变量到底什么类型的。从而辅助ts更加明确代码中每个成员的类型。</strong><br><strong>!!!重点!!!类型断言并不是类型转换，类型转换是代码运行时的概念，类型断言是编译过程中的概念， 编译后这个断言也就不存在了</strong></p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const nums = [1, 2, 4]const res = nums.find(i => i > 0)//此时res类型可能是number 或者 undefined 所以要使用断言指定类型// 断言写法:// as 关键字const num1 = res as number// jsx时不能使用 有语法冲突const num2 = <number>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类型声明？<br><strong>在实际开发中  ts中引入第三方模块，有的不是那ts写的， 就没有强类型的提示体验！！！</strong><br><strong>在使用第三方库过程中，如果当前模块不包含类型声明文件， 我们可以尝试安装对应模块的类型声明模块（一般为：＠types/…/）， 如果没有的话我们只能使用declare语法进行类型声明。 具体使用查看官方文档</strong></p></li></ul><h2 id="ts基础类型"><a href="#ts基础类型" class="headerlink" title="ts基础类型"></a>ts基础类型</h2><h3 id="一、原始类型7个"><a href="#一、原始类型7个" class="headerlink" title="一、原始类型7个"></a>一、原始类型7个</h3><pre class="line-numbers language-javaScript"><code class="language-javaScript"> const a: string = '123' const b: number = 123 const c: boolean = true const d: null = null const e: undefined = undefined const f: void = undefined const g: symbol = Symbol('123') console.log(a, b, c, d, e, f, g)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、其他类型"><a href="#二、其他类型" class="headerlink" title="二、其他类型"></a>二、其他类型</h3><h4 id="1-Object类型"><a href="#1-Object类型" class="headerlink" title="1.Object类型"></a>1.Object类型</h4><p>  不是单指普通的对象，可以是对象 数组  fun<br>  <code>const foo: object = {}  // []  // function() { }</code></p><h4 id="2-Array类型"><a href="#2-Array类型" class="headerlink" title="2.Array类型"></a>2.Array类型</h4><p>  <code>const arr1: number[] = [1, 2, 3]</code><br>  <code>const arr2: Array&lt;number&gt; = [1, 2, 3] // 泛型写法</code></p><h4 id="3-元组类型"><a href="#3-元组类型" class="headerlink" title="3.元组类型"></a>3.元组类型</h4><p>  明确元素数量以及元素类型的数组<br>  <code>const tuple: [number, string] = [2, '2']</code></p><h4 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4. 枚举类型"></a>4. 枚举类型</h4><p>  特点：给有一组数值给上更好理解的名字，一个枚举中只会出现固定的几个值不会出现超出范围的可能性</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  enum postState &#123;  draft = 0, // 值可以不指定， 默认从0累加。 如果初始化值是 字符串 必须手动给每个成员指定值 -不常见。  unpublished = 1  &#125;  // 常量枚举  const enum postState2 &#123;  draft = 0,  unpublished = 1  &#125;  // 使用  const obj = &#123;  title: '',  state: postState.draft, // 0 1 2  state1: postState[0] // 可以使用索引值访问，  &#125;  // ps:我们在ts中使用的大部分类型经过编译转换后都会被移除掉，因为他只是为了我们在编译过程中做类型检查！而枚举不会，枚举会影响我们编译后的结果，他最终编译成一个双向的键值对对象：其实就是可以用键获取值 用值获取键。  // 如果确认我们代码中不会使用索引值方式获取枚举值 我们建议使用常量枚举，enum前面添加const。使用常量枚举，编译后枚举会被移除掉。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-函数类型"><a href="#5-函数类型" class="headerlink" title="5.函数类型"></a>5.函数类型</h4><p>  // 定义分为：1声明函数， 2函数表达式</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  // d参数可选， 必须放最后  // rest任意个数参数使用es6的  function func1 (a: number, b: number, d?: number, ...rest: number[]): string &#123;  return 'func1'  &#125;  func1(1, 2)  // 函数表达式，接收这个函数的变量也需要类型注解  vscode会推断出这个变量类型 (a: number, b: number) => string  const func2: (a: number, b: number) => string = function (a: number, b: number) &#123;  return 'func2'  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-任意类型any"><a href="#6-任意类型any" class="headerlink" title="6.任意类型any"></a>6.任意类型any</h4><p>  属于动态类型，ts不会对any做类型检查， 兼容js老代码时需要any类型</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  function func3 (val: any) &#123;  return JSON.stringify(val)  // stringify方法接收任意类型参数  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-接口类型-interface"><a href="#7-接口类型-interface" class="headerlink" title="7.接口类型-interface"></a>7.接口类型-interface</h4><p>  一种规范契约，可以用来约定对象的结构，我们使用一个接口就必须遵守这个接口的全部约定。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  interface userFace &#123;    age: number,    name: string,    title?: string // 可选成员    readonly content?: string // 只读成员,初始化后不可改变  &#125;  // 参数user使用接口  function getUser (user: userFace) &#123;    return user.age + user.name  &#125;  console.log(getUser(&#123; age: 18, name: 's' &#125;))  // 动态接口写法：  interface userFace2 &#123;    [key: string]: string // key代表属性名称任意名称string代表可以的类型， 第二个string代表键值的类型  &#125;  const cache: userFace2 = &#123;&#125;  cache.foo = 'val1'  cache.bar = 'val2'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8.泛型"></a>8.泛型</h4><p>  把我们定义时不明确的类型变成一个参数 ，使用时在传递这样的类型参数！</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  function createNumberArray (length: number, value: number) &#123;    // 因为Array对象默认创建是的any类型，所以我们要指定下他默认的类型  使用泛型指定    // const arr = Array(length).fill(value)    const arr = Array<number>(length).fill(value)    return arr  &#125;  const rest = createNumberArray(3, 100)  console.log(rest)  // ps:此时 createNumberArray函数只能创建数字类型的数组。 如果还想创建字符串类型的数组 就可以使用泛型参数，  // ！！！！！！泛型参数方法  改进 createNumberArray！！！！  // 一般泛型参数为T ，然后把函数中不明确的参数类型都改为T  function createArray<T> (length: number, value: T) &#123;    const arr = Array<T>(length).fill(value)    return arr  &#125;  // 泛型使用  const rest2 = createArray<string>(3, 'foo')  console.log(rest2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-node多服务启动</title>
      <link href="/posts/e22d.html"/>
      <url>/posts/e22d.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue项目-nodejs服务，如何前后端服务同时启动？"><a href="#vue项目-nodejs服务，如何前后端服务同时启动？" class="headerlink" title="vue项目+nodejs服务，如何前后端服务同时启动？"></a>vue项目+nodejs服务，如何前后端服务同时启动？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时我们在vue项目里使用了Nodejs 提供接口服务时，这时就需要执行node服务命令和前端项目服务。那有没有同时跑前端和后端的服务方法呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用 concurrently 并行地运行多个命令。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> concurrentlyoryarn add concurrently<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后更改 package.json 文件，scripts如下：</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">"scripts": &#123;  "start": "craco start",  "build": "scraco build",  "test": "craco test",  "eject": "react-scripts eject",  "node": "npm run serve --prefix nodeServer",  "dev": "concurrently npm:node yarn:start"&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了 –prefix nodeServer 就不用 cd nodeServer 文件夹了，也就是说运行 <strong>npm run node</strong> 就会跑后端的服务，相当于：<strong>npm run serve</strong><br>此时只需要<strong>npm run dev</strong> 就会执行 <strong>npm run node</strong> 和 <strong>npm run start</strong>  也就实现了同时启动了服务端和客户端。<br>ps:这里命令我有用了yarn也是可以的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue+node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/posts/9cde.html"/>
      <url>/posts/9cde.html</url>
      
        <content type="html"><![CDATA[<h1 id="vim是什么？"><a href="#vim是什么？" class="headerlink" title="vim是什么？"></a>vim是什么？</h1><p>vim/vi是Unix / Linux上最常用的文本编辑器而且功能非常强大。但是【只有命令，没有菜单。】</p><h1 id="Vscode-vim使用："><a href="#Vscode-vim使用：" class="headerlink" title="Vscode vim使用："></a>Vscode vim使用：</h1><p>y复制（先选中）<br>yy复制一行<br>nyy复制多行（n为行数）<br>p粘贴<br>u撤销<br>移动光标至所选行的开头，按v进入视图，键盘上按向下键，选中所需行即可。<br>恢复刚才的操做 ctrl+r<br>v+w 打开选中模式，并向后移动一个单词<br>v+b 打开选中模型，并向前移动一个单词<br>v+i+w 打开选中模式，并选中当前单词</p><h1 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h1><h2 id="一、默认normal模式"><a href="#一、默认normal模式" class="headerlink" title="一、默认normal模式"></a>一、默认normal模式</h2><p>  正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一般的键/键组合会被当成功能键，而不会键入对应的字符。在这个模式下，我们可能通过键盘在文本中跳来跳去，跳动的范围从小到大是字符、单词、行、句子、段落和屏幕。启动vim后默认位于正常模式。不论位于什么模式，按下<esc>键(有时需要按两下）都会进入正常模式。</esc></p><h3 id="1、移动"><a href="#1、移动" class="headerlink" title="1、移动"></a>1、移动</h3><p>  <font color="red">单词:</font><br>  w=  word 向后移动单词<br>  b=  back word向前后移动单词<br>  <font color="red">行:</font><br>  0行首<br>  I单词行首<br>  $ 行尾<br>  A单词行尾<br>  15gg跳转到15行<br>  :18 = 进入18行<br>  18G =进入18行<br>  gg文件首行<br>  G文件末行<br>  Shift + [] 是以「代码块」为单位跳行<br>  Ctrl + u 和 Ctrl + d 实现上下滚动页面，滚动行数默认为半页大小<br>  [[ 跳到文件首行，而 ]] 则是行末。<br>  gd: 函数的跳转 go to defined<br>  ctr+o 退出到原先的函数位置<br>  当前行下移一行 :m+<br>  当前行上移一行 :m-2</p><h3 id="2、增"><a href="#2、增" class="headerlink" title="2、增"></a>2、增</h3><p>  d = delete 删除 d是开启剪切模式<br>  x= 删除一个字符<br>  dG = 删除全部<br>  3x = 3个字符<br>  dd= 剪切一行/ndd删除n是数字<br>  dw = delete word 删除一个单词-光标在单词位置<br>  diw = delete inner word 删除一个单词进入插入模式<br>  daw = delete around word 包含空格<br>  s是删除当前光标所指并转为 insert 模式</p><h3 id="3、删"><a href="#3、删" class="headerlink" title="3、删"></a>3、删</h3><h3 id="4、改"><a href="#4、改" class="headerlink" title="4、改"></a>4、改</h3><p>  c= change<br>  cc= 删除一行并且进入写入模式<br>  i(  =会选中括号里面的单词<br>  i”  = 会选中””引号里内容</p><p>  a(  =会选中括弧以及括弧里面的单词<br>  a”  = 会选中””和内容<br>  iw  = 会选中一个单词<br>  aw=会选中单词以及单词前面的一个空格</p><p>  ciw=删除一个单词并进入插入模式<br>  ct) = 光标不在括号内，修改到右括号，<br>  ct) =光标在括号内容第一个字符，删除()内容进入插入模式 </p><p>  以下命令可以对标点内的内容进行操作。<br>  ci’、ci”、ci(、ci[、ci{、ci&lt; - 分别更改这些配对标点符号中的文本内容<br>  di’、di”、di(或dib、di[、di{或diB、di&lt; - 分别删除这些配对标点符号中的文本内容<br>  yi’、yi”、yi(、yi[、yi{、yi&lt; - 分别复制这些配对标点符号中的文本内容<br>  vi’、vi”、vi(、vi[、vi{、vi&lt; - 分别选中这些配对标点符号中的文本内容</p><h3 id="5、查"><a href="#5、查" class="headerlink" title="5、查"></a>5、查</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>  查找’name’: <code>/name</code>  n向下 N向上<br>  取消查找高亮命令: <code>:nohl</code><br>  在normal模式下按下*即可查找光标所在单词<br>  在查找模式中加入\c表示大小写不敏感查找，\C表示大小写敏感查找。<br>  例如：<code>/foo\c</code> 将会查找所有的”foo”,”FOO”,”Foo”等字符串。</p><h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><p>  :s（substitute）命令用来查找和替换字符串<br>  例如:<code>%s/foo/bar/g</code> 会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）<br>  g即是替换标志之一，如： i表示大小写不敏感查找，I表示大小写敏感。<br>  还有空替换标志表示只替换从光标位置开始，目标的第一次出现：<br>  <code>:%s/foo/bar</code></p><p>  作用范围分为当前行、全文、选区等等。<br>  当前行：<br>  <code>:s/foo/bar/g</code><br>  全文：<br>  <code>:%s/foo/bar/g</code><br>  选区，在Visual模式下选择区域后输入:，Vim即可自动补全为 :’&lt;,’&gt;。<br>  <code>:'&lt;,'&gt;s/foo/bar/g</code><br>  2-11行：<br>  <code>:5,12s/foo/bar/g</code><br>  当前行.与接下来两行+2：<br>  <code>:.,+2s/foo/bar/g</code></p><h2 id="二、insert插入模式"><a href="#二、insert插入模式" class="headerlink" title="二、insert插入模式"></a>二、insert插入模式</h2><p>  在正常模式中按下i, I, a, A等键，会进入插入模式。<br>  小写包含空格，大写不包含空格<br>  a/A = append： 后面插入<br>  i /I = insert :前面插入<br>  o/O = open a line ：另起一行<br>  现在只用记住按i键会进行插入模式。插入模式中，击键时会写入相应的字符。</p><h2 id="三、visual可视模式"><a href="#三、visual可视模式" class="headerlink" title="三、visual可视模式"></a>三、visual可视模式</h2><p>  在正常模式按下v, V, <ctrl>+v，可以进入可视模式。可视模式中的<br>  操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</ctrl></p><h2 id="四、command命令模式"><a href="#四、command命令模式" class="headerlink" title="四、command命令模式"></a>四、command命令模式</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础</title>
      <link href="/posts/f82e.html"/>
      <url>/posts/f82e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Markdown？"><a href="#什么是Markdown？" class="headerlink" title="什么是Markdown？"></a>什么是Markdown？</h1><p>Markdown 设计灵感主要来源于纯文本电子邮件的格式，目标是让人们能够使用易读、易写的纯文本格式编写文档，而且这些文档可以转换为 HTML（Hyper Text Markup Language，超文本标记语言）文档。</p><p>简单来说，Markdown 是由一些简单的符号（如*/-&gt;[]()#）组成的用于排版的标记语言，其最重要的特点就是可读性强。</p><p>Markdown 相当于简化了的 HTML，它只提供用户最常用的语法格式，更易读和易写，用户可以不必关心复杂的 HTML 标签，只专注于写作就行了。</p><p>常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><h1 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h1><p>直接创建，没啥限制和要求。<br>排版简单，可读、直观、学习成本低<br>支持插入图片，视频等等（根据平台不同而定）<br>轻松的导出 HTML、.md 文件<br>可跨平台同步数据<br>随时可修改（不必像word等易混乱）</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code>一级标题对应一个 # 号；二级标题对应两个 # 号；以此类推。。。一共六级标题。</code></pre><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><pre><code>&lt;font face="黑体" color=green size=5&gt;黑体，绿色，尺寸为5（任意内容）&lt;/font&gt;or$\color{red}{红色字}$</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code>[name:大话卷积神经网络CNN（title:干货满满）](url:https://blog.csdn.net/TeFuirnever/article/details/100057229)or&lt;https://blog.csdn.net/TeFuirnever/article/details/100057229&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![图片描述](图片地址)支持 jpg、png、gif、svg 等图片格式，其中 svg 文件仅可在微信公众平台中使用。</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><pre><code>单行代码：代码之间分别用一个反引号包起来即可Use the `printf()` function.代码块高亮：``` key  支持多种语言 js java bash ....代码块```</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code>可以在一行中用3个 - 或者 * 来建立一个分隔线，同时需要在分隔线的上面空一行，如下：---或者**** * ******- - -</code></pre><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><pre><code>删除线的使用，在需要删除的文字前后各使用两个 ~~~这是要被删除的内容。~~</code></pre><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><pre><code>下划线的使用，在需要添加下划线的文字首部和尾部加上 &lt;u&gt;文本&lt;/u&gt;，如下：&lt;u&gt;这行文字已被添加下划线&lt;/u&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD\Linux\git常用命令</title>
      <link href="/posts/c9f9.html"/>
      <url>/posts/c9f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用终端命令"><a href="#常用终端命令" class="headerlink" title="常用终端命令"></a>常用终端命令</h1><h2 id="一、git"><a href="#一、git" class="headerlink" title="一、git"></a>一、git</h2><h3 id="git其他"><a href="#git其他" class="headerlink" title="git其他"></a>git其他</h3><pre><code>github浏览器快捷查看文件方式： github后面添加1s地址栏直接  https://github.com/ 修改为github1s.com我的git-pages地址: https://silin001.github.io</code></pre><p>git本地查找密钥：gitbash打开终端窗口：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> ~/.ssh<span class="token function">cat</span> id_rsa.pub 查看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="git初始化"><a href="#git初始化" class="headerlink" title="git初始化"></a>git初始化</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> status<span class="token function">git</span> log  <span class="token comment" spellcheck="true"># 显示提交日志</span><span class="token function">git</span> config --global user.name <span class="token string">"xxx"</span>    <span class="token comment" spellcheck="true"># 配置用户名</span><span class="token function">git</span> config --global user.email <span class="token string">"xxx@xxx.com"</span>  <span class="token comment" spellcheck="true"># 配置邮件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-push、git-pull"><a href="#git-push、git-pull" class="headerlink" title="git push、git pull"></a>git push、git pull</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone URL  <span class="token comment" spellcheck="true">#拉取远程代码到本地</span><span class="token function">git</span> commit -m <span class="token string">"提交内容"</span> <span class="token comment" spellcheck="true">#提交暂存区的更改，并记录下备注</span><span class="token function">git</span> push origin main <span class="token comment" spellcheck="true">#将完成的项目推送到远程仓库中</span><span class="token function">git</span> pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span>  <span class="token comment" spellcheck="true">#从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch ：查看本地分支<span class="token function">git</span> branch -r ：查看远程分支<span class="token function">git</span> branch -a ：查看本地和远程分支<span class="token function">git</span> branch 分支名字 ：新建本地分支<span class="token function">git</span> branch -d 分支名字 ：删除本地分支 （分支被合并后才允许删除 ，把 -d 改成 -D 强制删除）<span class="token function">git</span> branch -m 旧的分支名字 新的分支名字 ：重新命名分支<span class="token function">git</span> branch --merged：查看哪些分支已经合并到当前分支<span class="token function">git</span> branch --no-merged：查看当前哪些分支还没有合并到当前分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout --<span class="token operator">&lt;</span>file<span class="token operator">></span> ：撤销上一次对文件的操作<span class="token function">git</span> checkout  想要切换的分支名：从当前所处的分支切换到其他分支（当切换分支的时候，需要把暂存区里面的文件进行提交,不然暂存区里面的文件会跟着到切换的这条分支上<span class="token punctuation">)</span><span class="token function">git</span> checkout -b <span class="token operator">&lt;</span>branch-name<span class="token operator">></span>：新建并切换到新建分支上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、cmd"><a href="#二、cmd" class="headerlink" title="二、cmd"></a>二、cmd</h2><font color="red">ps: cmd和vscode终端部分操作不同！</font><p>dir -查看目录</p><h3 id="1、文件夹："><a href="#1、文件夹：" class="headerlink" title="1、文件夹："></a>1、文件夹：</h3><p>md  - 创建文件夹<br>rm - 只能删除空文件夹      /   cmd：rd 删除文件夹<br>rm /s  删整个文件夹  /q不提示</p><h3 id="2、文件："><a href="#2、文件：" class="headerlink" title="2、文件："></a>2、文件：</h3><p>del [filename] - 删除文件<br>首先是创建空文件，命令type nul&gt;[filename]<br>命令echo [fileContent]&gt;[filename] 向文件写入内容</p><h2 id="三、Linux"><a href="#三、Linux" class="headerlink" title="三、Linux"></a>三、Linux</h2><p>mkdir ‘’  创建目录<br>rm -r test 删除目录<br>touch ‘’ 创建文件<br>rm  文件名 删除<br>打开文件： vi　文件名　<br>退出打开的文件　　ｑ：　不报错强制　退出　ｑ！<br>搜索目录【查】find<br>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 终端命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd、git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hello-world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
