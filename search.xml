<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于服务端遇到的相关问题记录</title>
      <link href="/posts/b032.html"/>
      <url>/posts/b032.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于服务端遇到的相关问题"><a href="#关于服务端遇到的相关问题" class="headerlink" title="关于服务端遇到的相关问题"></a>关于服务端遇到的相关问题</h2><h3 id="axios相关"><a href="#axios相关" class="headerlink" title="axios相关"></a>axios相关</h3><ul><li>请求头相关<br>axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。<br>也就是说，我们的 <code>Content-Type</code> 变成了 <code>application/json;charset=utf-8</code>  （注意结尾不要带分号;）,这是axios默认的请求头content-type类型。</li></ul><p>post请求常见的数据格式、请求头（content-type）<br>  <code>Content-Type: application/json</code>： 请求体中的数据会以json字符串的形式发送到后端 如： {a:123}<br>  <code>Content-Type: application/x-www-form-urlencoded</code>：请求体中的数据会以普通表单形式（键值对，k=v写法）发送到后端  body中：a=100<br>  <code>Content-Type: multipart/form-data</code>： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。</p><p>客户端解决 <code>Content-Type: multipart/form-data</code> 的数据类型传参 ？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式  formData</span><span class="token comment" spellcheck="true">/* FormData对象的使用：  用一些键值对来模拟一系列表单控件：即把form中所有的元素的name与value组成一个queryString。  异步上传二进制文件。  对于这种类型的数据，我们常见前端页面上传个人图像，然后点击保存发送后端修改原始数据 如下：*/</span>   <span class="token keyword">let</span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// const name = params.get("userName") // 还可以获取</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>file<span class="token punctuation">)</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'userID'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'userName'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'email'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>email<span class="token punctuation">)</span>        params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'qq'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>qq<span class="token punctuation">)</span>        axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>URL<span class="token punctuation">,</span> params<span class="token punctuation">,</span> <span class="token punctuation">{</span>headers<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'multipart/form-data'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>code <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'更新用户数据失败'</span> <span class="token operator">+</span> error<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端解决<code>application/x-www-form-urlencoded</code> 形式的传参？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式1：  URLSearchParams</span><span class="token comment" spellcheck="true">// 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案</span><span class="token keyword">let</span> param <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span>param<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">)</span>param<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'pwd'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">)</span><span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    method<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>    url<span class="token punctuation">:</span> <span class="token string">'/api/lockServer/search'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> param<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 方式2：qs 转换数据为key=value格式</span><span class="token comment" spellcheck="true">// 引入 qs ，这个库是 axios 里面包含的，不需要再下载。</span><span class="token keyword">import</span> Qs <span class="token keyword">from</span> <span class="token string">'qs'</span><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"cc"</span><span class="token punctuation">,</span>    <span class="token string">"psd"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">}</span><span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/x-www-form-urlencoded'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>    url<span class="token punctuation">:</span> <span class="token string">'/api/lockServer/search'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> Qs<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="部署服务器后遇到的问题记录"><a href="#部署服务器后遇到的问题记录" class="headerlink" title="部署服务器后遇到的问题记录"></a>部署服务器后遇到的问题记录</h3><ul><li>客户端代码部署服务器后代理访问接口未授权？<br>客户端代码请求了第三方服务接口，接口请求头添加了自定义请求头类似 <code>__s__</code> <code>__token__</code> <code>_token_</code>，浏览器里可以看到这些请求头，但是接口是服务端nginx代理，nginx默认会过滤掉请求头包含<code>_ 、 -</code> 的字段，导致这些参数消失请求失败。</li></ul><h3 id="node服务部署服务器遇到问题"><a href="#node服务部署服务器遇到问题" class="headerlink" title="node服务部署服务器遇到问题"></a>node服务部署服务器遇到问题</h3><ul><li><p>添加5000端口外网访问不到？<br>宝塔面板启动后，默认linux服务器防火墙开启了，需手动关闭防火墙</p><blockquote><p>my服务器配置<br>1vCPUs | 2GB<br>CentOS 8.2 64bit<br>命令：<br>查看防火状态<br><code>systemctl status firewalld</code><br>暂时关闭防火墙<br><code>systemctl stop firewalld</code><br>永久关闭防火墙<br><code>systemctl disable firewalld</code><br>重启防火墙<br><code>systemctl enable firewalld</code></p></blockquote><p>查看5000端口是否被监听<br><code>ss -nutlp | grep 5000</code></p><p><em>curl使用</em><br>查看某地址是否可访问</p><blockquote><p>curl <a href="http://123.60.111.103:5000">http://123.60.111.103:5000</a><br>curl <a href="http://localhost:5000">http://localhost:5000</a></p></blockquote></li><li><p>node服务启动文件监听ip？<br>node服务启动文件 监听ip一定要写成 <code>0.0.0.0</code> 或者可以省略不写；由于我写成了<code>127.0.0.0</code>导致部署服务器后访问失败！</p></li><li><p>一般外网无法访问服务器指定端口排查如下<br>排查服务商对应端口安全组是否开放？<br>排查服务器对应端口是否放行<br>排查服务器防火墙是否关闭</p></li><li><p>服务器使用pm2<br>服务器使用pm2启动node服务失败<br>在云服务器上使用pm2管理node服务器进程，启动时失败。mysql连接 host为localhost时可以，换成服务器公网ip就不行了。排查后发现是因为服务器数据库权限没添加对应ip！！</p></li><li><p>mysql数据库自动关闭<br>解决<code>nodejs的Connection lost: The server closed the connection</code><br>原因：mysql自带一段时间无动作会自动关闭的机制<br>node服务部署服务器后默认8小时不操作数据库会自动关闭，解决方法：使用连接池</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> node 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙里办H5接入爬坑</title>
      <link href="/posts/a6b9.html"/>
      <url>/posts/a6b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录个人遇到的-h5应用接入’浙里办’-的爬坑之路！"><a href="#记录个人遇到的-h5应用接入’浙里办’-的爬坑之路！" class="headerlink" title="记录个人遇到的 h5应用接入’浙里办’ 的爬坑之路！"></a>记录个人遇到的 h5应用接入’浙里办’ 的爬坑之路！</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近接到一个公司之前使用vue2.0  vue-cli2搭建的一个H5项目，现在要求接入到 浙里办APP、浙里办-支付宝小程序。说难吧 刚开始可能由于该项目的经理没有讲的太清除，导致我和后端哥们二脸懵逼！！！<br>就简单告诉我们app改造接入浙里办，然后群发了 语雀(<a href="https://odynww.yuque.com/docs/share/525e3e8a-ad52-421b-90da-2d76808e3050?#DB3a8">https://odynww.yuque.com/docs/share/525e3e8a-ad52-421b-90da-2d76808e3050?#DB3a8</a>) 这篇文档。  也没和我们讲’浙里办’是什么？之前的app是干嘛用的！对于没接触过这个方向的同学来说简直是懵逼和无奈，直接阅读这么长一篇文档的话那就是浪费很多时间。 无从下手的我们只能先请教了之前接触过的项目经理给我们大致讲了讲流程才大致明白了。接下来在开发过程中发现要注意的东西还是挺多的，踩了很多坑，特以此篇记录，也为能帮助到初次接触这方面的同学。</p><h3 id="文档阅读"><a href="#文档阅读" class="headerlink" title="文档阅读"></a>文档阅读</h3><p>拿到技术对接浙里办的文档时，一定要多阅读几遍！！！因为第一次接触这方面，内容也多，理解能力不是特别强的同学没几遍还真整不明白。整个文档内容基本了解以后就可以专注前端开发部分了。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>首先问项目负责人要文档中说的 应用开发管理平台相关账号，这个平台也就是浙里办的应用中台。我们的h5应用开发完打包后需要上传到这个平台，然后测试、发布上线。<br>我们应用一部分内容需要调用浙里办的JSBridge API调用原生功能。所以需要官网提供的debug工具后续接口调试用到。</p><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>浙里办是硬性要求用户数据都是要走他那边的登录的，针对这个要求，前需要把登录操作的页面跳转直接改为浙里办提供的登录地址。<em>参考文档 1.1.7.3 个人登录</em><br>首先单点登录分为：个人用户的单点登录和法人用户的单点登录。我这里只做了个人用户登录。<br>个人登录又分为：浙里办app环境登录 和 浙里办-支付宝小程序环境登录。<br><em>环境判断见文档：1.1.7.1.浙里办APP、支付宝-浙里办小程序的判断代码</em></p><p>⭐⭐⭐个人登录注意点：<br>需要用到接入码、这个接入码也是找项目负责人由甲方配置提供；goto跳转地址就是我们前端应用的首页，这个地址需要提供给甲方让他们配置好。<br>这样我们就按照文档拼接成了一个登录的跳转地址。<br>等他们把跳转地址配置完之后，用户操作一个涉及到用户读取却没有登录的地方时，就跳转到了浙里办的登录页面地址，然后输入自己的账号密码点击登录，这时候登录成功后页面会自动的跳转到你在第二部分goto设置的回调地址上，也就是我们h5应用的（一般为）首页。<br>在跳回来的过程中会在 URL 路径上带有登录时返回给你的 ticket 等参数，此时前端需要从url里取出这个标识传给后端进行①票据认证 ②票据认证完会返回一个token 这时就可以拿这个token 获取到用户信息了。 为了简洁操作 这里我们做的时候直接把ticket传给服务端，服务端处理完 直接把用户信息返回给了我客户端。</p><h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><p>他们提供的文档很模糊，我在初次接触这块的时候还是在网上查找了大量资料完成。<br>基础埋点如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> d<span class="token punctuation">,</span> s<span class="token punctuation">,</span> q<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    w<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> f <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>j <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'beacon-aplus'</span><span class="token punctuation">;</span>    j<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'https://alidt.alicdn.com/alilog/mlog/aplus_cloud.js'</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">,</span> <span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token string">'aplus_queue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'aplus-rhost-v'</span><span class="token punctuation">,</span> <span class="token string">'alog.zjzwfw.gov.cn'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'aplus-rhost-g'</span><span class="token punctuation">,</span> <span class="token string">'alog.zjzwfw.gov.cn'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> u <span class="token operator">=</span> navigator<span class="token punctuation">.</span>userAgent  <span class="token keyword">var</span> isAndroid <span class="token operator">=</span> u<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'Android'</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token keyword">var</span> isIOS <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>u<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span><span class="token punctuation">)</span>  aplus_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    action<span class="token punctuation">:</span> <span class="token string">'aplus.setMetaInfo'</span><span class="token punctuation">,</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'appId'</span><span class="token punctuation">,</span> <span class="token string">'your appid'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他pv\uv相关埋点建议写成单独js文件需要的埋点的页面引入，在vue项目里直接写到vue实例里可能导致埋点不成功。</p><h3 id="接口调试"><a href="#接口调试" class="headerlink" title="接口调试"></a>接口调试</h3><p>调试JSBridge API时，就需要用到上面提到的debug工具。调试的过程中手机浙里办app 需要全程在线才能一直连接调试、屏幕熄灭也会断开。<br>所有关于浙里办的 JSBridge API 的原生访问接口都需在真机上测试，浏览器是不行的！通过登录浙里办app 应用平台上传测试版本生成的二维码，可以查看效果。在扫码之前确定项目里引入了JSBridge API 资源。</p><h3 id="二次回退问题"><a href="#二次回退问题" class="headerlink" title="二次回退问题"></a>二次回退问题</h3><p>我这里遇到的问题是 应用首页返回浙里办app时需要2次或者多次点击才可返回，解决方案：利用router.beforeEach 判断路由然后调用 政务api的close关闭接口</p><h3 id="支付宝小程序测试问题"><a href="#支付宝小程序测试问题" class="headerlink" title="支付宝小程序测试问题"></a>支付宝小程序测试问题</h3><p>应用管理平台发布上线后生成的访问地址二维码是给浙里办APP用的！！！支付宝扫码访问需要自己去转换：（<a href="https://3pwls.csb.app/）">https://3pwls.csb.app/）</a> 在这个网页中输入你浙里办预览二维码的网址，然后转换成支付宝能识别的二维码就可以在支付宝中看效果了。<br>原理：其实就是浙里办的支付宝小程序内嵌了一个浏览器，用这个内嵌的浏览器就可以调用浙里办的JSBridge了。</p><h3 id="h5适老化"><a href="#h5适老化" class="headerlink" title="h5适老化"></a>h5适老化</h3><p>自建h5应用接入浙里办以后还需要‘适老化’版本的开发，所谓‘适老化’ 主要是适应于年龄稍微大点的长辈，也就是长辈版。适老化版本内容、功能要求和标准版一致，标准版下架后理应适老化版本也一同下架，应为一个系统应用。这里我是使用了两版路由实现了不同环境的版本切换。</p><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><p>前端应用不需要打包，只需要将项目src static index.html package.json gbc.json .postcssrc.js .babelrc 等资源依赖压缩为.zip的包 且不能大于40M,然后上传到 政务中台应用管理等编译通过后就生产二维码和链接可以查看测试版本了。<br>⭐⭐⭐这里我遇到了一个坑！！！ 之前公司前端开发好的h5应用使用的图片有部分是中文命名，结果windows系统打包zip压缩后中文乱码了，导致上传应用平台编译失败，而mac系统打包不会乱码！切记开发中不要使用中文资源！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然整个项目最开始是懵逼和无奈的，过程是崎岖和痛苦的，但是完成的那一刻心里还是挺开心的！说实话东西没多难，但是我觉得初次接触一个新事物、新项目的时候还是得先整明白 是什么？干什么？完成什么？ 只有清楚这些才能理清思路和步骤然后再去进阶完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> H5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-study</title>
      <link href="/posts/8d7.html"/>
      <url>/posts/8d7.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue3-x-开始"><a href="#vue3-x-开始" class="headerlink" title="vue3.x 开始"></a>vue3.x 开始</h2><p>2020年 9.18发布3.0版本、代号： One Piece (海贼王)，耗时两年，2600+提交，99位贡献者。</p><h2 id="vue2-x-面临的问题"><a href="#vue2-x-面临的问题" class="headerlink" title="vue2.x 面临的问题"></a>vue2.x 面临的问题</h2><p>vue2.x版本发布于数年前，基于es5的技术架构，受限于当时通用浏览器的版本问题，在某些功能方面做了一些妥协：</p><ul><li>监听数据的方法<code>Object.definePerproty</code>, 不能对Object类型做深度监听。而为了深度监听，以及为了达到目的所要付出的代价，也就是<strong>递归遍历</strong>侦听数据</li><li><code>optionsApi</code>存在问题，功能分块混乱，我们需要把逻辑分别散落在<code>data，methods、computed</code>对象里，新增一个需求就需要分别在各项里修改，来回滚动</li><li>vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行</li><li>ts支持不友好</li></ul><h2 id="2-0-3-0-实现原理"><a href="#2-0-3-0-实现原理" class="headerlink" title="2.0 / 3.0 实现原理"></a>2.0 / 3.0 实现原理</h2><ul><li><p>Vue2.0： 实现MVVM(双向数据绑定)的原理是通过 <code>Object.defineProperty</code> 来劫持各个属性的<code>setter、getter</code>在数据变动时发布消息给订阅者，触发相应的监听回调。<br>缺点：<br>基于<code>Object.defineProperty</code> 不具备监听数组的能力，需要重写数组的原型方法来达到响应式。<br><code>Object.defineProperty</code> 无法检测到对象属性的添加和删除 。<br>由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。<br>深度监听需要一次性递归，对性能影响比较大</p></li><li><p>Vue3.0： 重构响应式系统，使用<code>Proxy</code>代理 + <code>Reflect</code>反射，替换<code>Object.defineProperty</code><br>使用Proxy代理优势：<br>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样<em>递归遍历每个属性</em>，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>不需要一次性遍历data的属性，可以显著提高性能。<br>因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11<br>源码:</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> proxyData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>receive<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 只处理本身(非原型)的属性</span>   <span class="token keyword">const</span> ownKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ownKeys<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 监听</span>   <span class="token punctuation">}</span>   <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>receive<span class="token punctuation">)</span>   <span class="token keyword">return</span> result <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> reveive<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 重复的数据，不处理</span>   <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token boolean">true</span>   <span class="token punctuation">}</span>   <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span>reveive<span class="token punctuation">)</span>   <span class="token keyword">return</span> result <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 删除属性</span> <span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span>   <span class="token keyword">return</span> result <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="vue3带来了什么？"><a href="#vue3带来了什么？" class="headerlink" title="vue3带来了什么？"></a>vue3带来了什么？</h2><p>打包大小减少41%、初次渲染快55%、更新渲染快133%、内存减少54%</p><ul><li>新增<code>Composition API</code>更好的逻辑复用和代码组织<br>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。<br><code>Composition Api</code>的出现，主要是也是为了解决Option API带来的问题<br>第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。<br>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</li><li>重构<code>Virtual DOM</code><br>Vue2 中的虚拟dom 是进行全量对比<br>Vue3 新增静态标记，模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li></ul><h2 id="Vue3-x搭建起步"><a href="#Vue3-x搭建起步" class="headerlink" title="Vue3.x搭建起步"></a>Vue3.x搭建起步</h2><p>安装好vue-cli后， 终端输入vue -V  出现4.5.x以上版本为3.x的脚手架。</p><pre class="line-numbers language-bash"><code class="language-bash">使用脚手架创建第一个3.x项目：Vue create vue3demo01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>Vite</code>创建项目:</p><pre class="line-numbers language-bash"><code class="language-bash">全局安装vite：<span class="token function">npm</span> <span class="token function">install</span> -g create-vite-app创建项目create-vite-app yourProjectName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>npm:<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> init @vitejs/app  按照提示操作or<span class="token function">npm</span> init @vitejs/app my-vue-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>yarn:<pre class="line-numbers language-bash"><code class="language-bash">yarn create @vitejs/app  按照提示操作oryarn create @vitejs/app my-vue-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>你还可以通过附加的命令行选项直接指定项目名称和你想要使用的模板</li></ul><pre class="line-numbers language-bash"><code class="language-bash">例如，要构建一个 Vite + Vue 项目运行:yarn create @vitejs/app my-vue-app --template vue例如创建 vue+ts：yarn create @vitejs/app my-vue-app --template vue-ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h2><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。<br>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。<br>使用SSR的好处：</p><ul><li>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</li><li>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试相关题</title>
      <link href="/posts/69af.html"/>
      <url>/posts/69af.html</url>
      
        <content type="html"><![CDATA[<h2 id="面试题相关"><a href="#面试题相关" class="headerlink" title="面试题相关"></a>面试题相关</h2><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><ul><li>html语义化？<blockquote><p>通过使用包含语义的标签(如h1-h6，header、footer、nav)恰当地表示文档结构；<br>增强代码可读性、<br>方便搜索引擎能识别页面结构，利于seo、<br>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构</p></blockquote></li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>css 选择器优先级<blockquote><p>!important &gt; 内联样式 &gt; id选择 &gt; （class选择 = 伪类选择） &gt; (标签选择 = 伪元素选择)</p></blockquote></li></ul><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><ul><li>undefined 和 null 区别<blockquote><p>1、null<br>什么都没有，表示一个空对象引用（主动释放一个变量引用的兑现那个，表示一个变量不再指向任何引用地址）<br>2、undefined<br>没有设置值的变量，会自动赋值undefined<br>区别<br>typeof undefined             // undefined<br>typeof null                  // object<br>null === undefined           // false<br>null == undefined            // true</p></blockquote></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><p>HTTP和HTTPS的区别</p><blockquote><p>HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用<br>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。<br>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p></blockquote></li><li><p>http请求状态码</p><blockquote><p>以 2xx 为开头的都表示请求成功响应.<br>状态码含义<br>200请求成功<br>204请求处理成功，但是没有资源可以返回<br>206对资源某一部分进行响应，由Content-Range 指定范围的实体内容。</p></blockquote><blockquote><p>以 3xx 为开头的都表示需要进行附加操作以完成请求<br>状态码含义<br>301永久性重定向，该状态码表示请求的资源已经重新分配 URI，以后应该使用资源现有的 URI<br>302临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。<br>303该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br>304该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。<br>307临时重定向。该状态码与 302 Found 有着相同的含义。</p></blockquote><blockquote><p>以 4xx 的响应结果表明客户端是发生错误的原因所在。<br>状态码含义<br>400该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。<br>401该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。<br>403该状态码表明对请求资源的访问被服务器拒绝了。<br>404该状态码表明服务器上无法找到请求的资源。</p></blockquote><blockquote><p>以 5xx 为开头的响应标头都表示服务器本身发生错误<br>状态码含义<br>500该状态码表明服务器端在执行请求时发生了错误。<br>503该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></blockquote></li></ul><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li>网页从输入网址到渲染完成经历了哪些过程？<blockquote><p>输入网址<br>域名解析（发送到DNS服务器，并进行查找获取域名对应的web服务器对应的ip地址【包含浏览器缓存，路由器缓存，DNS缓存查找】）<br>建立连接 （与web服务器建立TCP连接）<br>发送请求（浏览器向web服务器发送http请求）<br>响应请求，返回数据（web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址））<br>下载数据（浏览器下载web服务器返回的数据及解析html源文件；）<br>解析渲染（生成DOM树，解析css和js，渲染页面，直至显示完成）</p></blockquote></li></ul><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul><li>vue响应式数据原理？<blockquote><p>Vue 的响应式，核心机制是 观察者模式。<br>vue2.x: 核心是利用 <code>object.defineProperty</code> （不兼容 IE8 ）把 data 中的属性遍历，转化为 getter 和 setter 监听数据。<br>vue3.x: 更改数据劫持方法，利用es6 <code>proxy</code> + <code>Reflect</code> 实现数据劫持<br>ES6 中 Proxy 目前提供了 13 种可代理操作，直接操作对象本身。</p></blockquote></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js相关</title>
      <link href="/posts/e9a0.html"/>
      <url>/posts/e9a0.html</url>
      
        <content type="html"><![CDATA[<h1 id="js重点"><a href="#js重点" class="headerlink" title="js重点"></a>js重点</h1><h2 id="js-DOM事件流"><a href="#js-DOM事件流" class="headerlink" title="js-DOM事件流"></a>js-DOM事件流</h2><p>事件发生时，会在元素节点之间按照特定的顺序传播，这个传播过程既‘DOM事件流’</p><ul><li><p>事件传播三个阶段<br>w3c将 事件传播 分成3个阶段：<br>捕获：从最外层祖先元素向目标元素进行捕获此时不会触发事件<br>目标：事件捕获到目标元素，捕获结束，开始在目标元素上触发事件<br>冒泡：事件从目标元素向他的祖先传递，依次触发祖先元素身上的事件</p></li><li><p>事件捕获<br>从外向里，一般情况下不会使用捕获阶段执行事件</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">addEventListener</span><span class="token punctuation">(</span>‘click’<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三个参数默认false 冒泡阶段</p></li><li><p>事件冒泡（事件默认是冒泡阶段）<br>事件默认是冒泡阶段</p></li><li><p>事件委托概念<br>利用事件冒泡机制实现事件委托，提供代码执行性能</p></li></ul><h2 id="数据类型-amp-隐式转换"><a href="#数据类型-amp-隐式转换" class="headerlink" title="数据类型&amp;隐式转换"></a>数据类型&amp;隐式转换</h2><ul><li><p>js数据类型分为基础类型和引用类型<br>原始类型（基本类型）：undefined、null、boolean、number、string<br>引用类型（复杂类型）：object</p></li><li><p>typeof 检测数据类型</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// object  为什么不是null   js历史遗留的一个bug</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// object</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// object</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// function</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// function  为什么不是object</span><span class="token comment" spellcheck="true">//js在设计时在引用类型内部方法[[call]] 方法， typeof 检测引用类型时看引用类型上有没有 [[call]] 方法，有返回 function， 没有返回 object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>instanceof<br>A 对象是否是 B 对象实例化后的对象</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true   为什么？</span><span class="token comment" spellcheck="true">// 因为 instanceof 是顺着原型链去检测的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>除了typeof方法，检测数据类型方法</p><pre class="line-numbers language-javascript"><code class="language-javascript">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Array</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>特殊类型的隐式转换<br>5种： NaN、0、undefined、null、””  =&gt; false / true<br>栗子：</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果val 为以上5种时隐式转换为 false</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 应该改为：</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="开发中一些概念"><a href="#开发中一些概念" class="headerlink" title="开发中一些概念"></a>开发中一些概念</h2><ul><li>重载和多态？<br>重载的概念： 在程序中可以定义相同的名字，不同参数形式的不同函数。调用函数时，自动识别不同参数对应的函数，实现了相同函数名，不同的函数调用。<br>js本身是没有重载的，但是可以通过arguments实现函数重载。根据参数不同返回不同结果，执行不同逻辑。很多框架底层源码就是这样实现重载的。<br>多态：同一个东西在不同情况下的表现不同状态。</li></ul><h2 id="js进阶概念"><a href="#js进阶概念" class="headerlink" title="js进阶概念"></a>js进阶概念</h2><ul><li><p>深、浅拷贝有那些方式？<br>概念： 假设B复制了A，当修改A时，看B是否发生变化，如果变化则是浅拷贝；如果B不变则是深拷贝。<br>浅拷贝常用：<br><code>for in 遍历</code> for in 目标对象取出key 创建新对象<br><code>Object.creat()</code> 会复制到<strong>proto</strong>原型上<br>深拷贝常用：<br><code>JSON.parse(JSON.stringify(obj))</code></p></li><li><p>什么是闭包？<br>函数和其周围的状态的引用捆绑在一起形成闭包<br>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域的成员。<br>闭包的本质：<br>函数在执行的时候会被放到一个执行栈上，当函数执行完毕后会从执行栈上移除。但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。<br>闭包的好处是：延长了外部函数他内部变量的作用范围。</p></li><li><p>什么的高阶函数？<br>可以把函数当作参数传递给另外一个函数<br>可以把函数当作另一个函数的返回结果<br>常用高阶函数：<br>ForEach、map、filter、some、reduce、stor、</p></li><li><p>什么是纯函数？<br>相同的输入永远会得到相同的输出，而且没有任何可观察的副作用</p><!-- 什么是副作用： --><p>slice:返回数组中的指定部分，不会改变原数组 —纯函数<br>Splice： 对数组进行操作返回该数组，会改变原数组 —非纯函数</p></li><li><p>什么是函数柯里化？<br>当一个函数有多个参数时，先传递一部分参数调用他（这部分参数以后永远不变）<br>然后返回一个新的函数接收剩余的参数，返回结果。<br>总结：<br>1、柯里化可以让我们给一个函数传递较少参数得到一个已经记住了某些固定参数的新函数<br>2、这是一种对函数参数的缓存<br>3、让函数变的更灵活，让函数的粒度更小<br>4、可以把多元函数转化为一元函数，可以组合使用函数产生强大的功能</p></li></ul><p>*什么是函数组合？<br>如果一个函数要经过多个函的处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。这些中间函数会相应得到中间结果这些结果我们不需要关注。函数组合默认是从右到左执行的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.0相关探秘</title>
      <link href="/posts/9108.html"/>
      <url>/posts/9108.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue2-0-相关实现原理记录"><a href="#vue2-0-相关实现原理记录" class="headerlink" title="vue2.0 相关实现原理记录"></a>vue2.0 相关实现原理记录</h1><h2 id="vue底层渲染过程大致可以分成4个阶段："><a href="#vue底层渲染过程大致可以分成4个阶段：" class="headerlink" title="vue底层渲染过程大致可以分成4个阶段："></a>vue底层渲染过程大致可以分成4个阶段：</h2><ul><li>template 模板解析后生成AST语法树<br>模板解析：通过正则等方式提取出 <template></template> 模板里的标签元素、属性、变量等信息，并解析成抽象语法树 AST</li><li>AST树解析生成对应的render函数：<br>AST是Abstract Syntax Tree的简称，Vue使用HTML的Parser将HTML模板解析为<strong>AST语法树</strong>，并且对AST进行一些优化的标记处理，提取最大的静态树，方便Virtual DOM时直接跳过Diff。</li><li>数据通过render函数（渲染函数）解析生成VNode<br>Virtual DOM：虚拟DOM树，Vue的Virtual DOM Patching算法是基于<code>Snabbdom</code>库的实现，并在些基础上作了很多的调整和改进。</li><li>VNode经过diff和patch后生成真实DOM展示</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>用js模拟dom结构，计算最小变更，操作dom</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"div1"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span> style<span class="token operator">=</span><span class="token string">"color: red"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>vdom<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span>ul style<span class="token operator">=</span><span class="token string">"font-size: 20px"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>a<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>js描述如下：<span class="token punctuation">{</span>    tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>    sel<span class="token punctuation">:</span> <span class="token punctuation">{</span>        id<span class="token punctuation">:</span> <span class="token string">'div1'</span><span class="token punctuation">,</span>        className<span class="token punctuation">:</span> <span class="token string">'container'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    props<span class="token punctuation">:</span> <span class="token punctuation">{</span> style<span class="token punctuation">:</span> <span class="token string">'color: red'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            tag<span class="token punctuation">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>            children<span class="token punctuation">:</span> <span class="token string">'vdom'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>            props<span class="token punctuation">:</span> <span class="token punctuation">{</span> style<span class="token punctuation">:</span> <span class="token string">'font-size: 20px'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            children<span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>                    children<span class="token punctuation">:</span> <span class="token string">'a'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vue中-diff算法"><a href="#vue中-diff算法" class="headerlink" title="vue中 diff算法"></a>vue中 diff算法</h3><p>只比较同一层级，不跨级比较。<br>tag不相同，直接删除重建，不做再深度比较。<br>tag和key相同，认为是同一节点，不做再深度比较。</p><ul><li>最小量更新，key很重要是节点的唯一标识，在更改前后告诉diff他是同一节点</li><li>只有是同一个虚拟节点才进行精细化比较，否则就暴力删除旧的插入新的，<br>同一虚拟节点？选择器相同，且key相同</li><li>只进行同层比较，不进行跨层级比较。<br>即使是同一片虚拟节点， 跨层了也不会进行diff 暴力删除旧的插入新的</li></ul><h3 id="vue中的-render函数"><a href="#vue中的-render函数" class="headerlink" title="vue中的 render函数"></a>vue中的 render函数</h3><ul><li>什么是render函数？<br>vue中在一些复杂场景下使用template模板不太方便，例如需要引入大量子组件时，使用template模板会使代码重复冗余，这时用render函数就可以轻松解决问题，而用render函数构建DOM，vue也免了去转译的过程。<br>在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM。</li><li>render函数作用？<br>生成虚拟DOM<br>当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。官网上给他起了个名字叫<code>createElement</code> 还有约定的简写叫<code>h</code>, vm中有一个方法<code>_c</code>,也是这个函数的别名。</li><li><code>render</code>函数的使用<br>比如说我们需要写很多 if 判断的时候</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>h1 v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"level === 1"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span>h2 v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"level === 2"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span>h3 v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"level === 3"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'level'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接写 render</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'level'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token function">render</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>level<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组数据响应式的处理原理"><a href="#数组数据响应式的处理原理" class="headerlink" title="数组数据响应式的处理原理"></a>数组数据响应式的处理原理</h3><p>重新数组方法，以<code>Arrap.prototype</code>为原型创建了一个<code>arrayMethods</code>的对象，在使用<code>es6</code>的一个强硬的方法<code>object.setPrototytypeOf(o,arrayMethods)</code>,让数组的<strong>proto</strong>指向<code>arrayMethods</code></p><h2 id="vue2-0-源码地址"><a href="#vue2-0-源码地址" class="headerlink" title="vue2.0 源码地址"></a>vue2.0 源码地址</h2><ul><li>项目地址：<a href="https://github.com/vuejs/vue">https://github.com/vuejs/vue</a></li><li>文件结构核心部分<pre><code>srccompiler 编译器相关core 核心代码  components 通用组件，如 keep-alive  global-api 全局 api，如$set、$delete  instance 构造函数等  observer 响应式相关  util  vdom 虚拟 dom</code></pre></li></ul><h2 id="vue2响应式原理-底层源码核心类"><a href="#vue2响应式原理-底层源码核心类" class="headerlink" title="vue2响应式原理-底层源码核心类"></a>vue2响应式原理-底层源码核心类</h2><p>栗子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"mvvm-app"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"word"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span>word<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token punctuation">:</span>click<span class="token operator">=</span><span class="token string">"sayHi"</span><span class="token operator">></span>change model<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span> <span class="token comment" spellcheck="true">//点击这个button，word的值会发生改变</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"./js/observer.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"./js/watcher.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"./js/compile.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"./js/mvvm.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MVVM</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span> <span class="token string">'#mvvm-app'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>      word<span class="token punctuation">:</span> <span class="token string">'Hello World!'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>      sayHi<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>word <span class="token operator">=</span> <span class="token string">'Hi, everybody!'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现这种数据双向绑定的效果，需要以下几大模块：</p><ul><li><p><code>Compile -模板编译</code>：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数.<br>Compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的<em>观察者watcher</em>，将来一旦数据有变动，收到通知触发回调函数进行更新视图。</p></li><li><p><code>Observer -数据劫持</code>：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者.<br>Observer的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。<br>get里: 初始化订阅数据变化时 往dep里添加观察者与其关联<br>set里: 通知；数据发生变化时dep去通知<em>观察者watcher</em></p></li><li><p><code>dep类 -发布者</code>：<br>作用：收集对应<em>观察者watcher</em>、通知watcher更新。<br>有多少属性dep里就有多少个watcher</p></li><li><p>订阅：addSub()*</p></li><li><p>发布：notify()*</p></li><li><p><code>Watcher -观察者（订阅者）</code>：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，在更改数据时进行watcher监听，把新值callback。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发中遇到的问题</title>
      <link href="/posts/ba1f.html"/>
      <url>/posts/ba1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="开发中问题记录"><a href="#开发中问题记录" class="headerlink" title="开发中问题记录"></a>开发中问题记录</h1><h2 id="npm项目依赖问题"><a href="#npm项目依赖问题" class="headerlink" title="npm项目依赖问题"></a>npm项目依赖问题</h2><ul><li>yarn 安装依赖后启动报错如下<br><code>Could not resolve "pdfast" (mark it as external to exclude it from the bundle)</code></li></ul><p><code>@antv/g2plot</code> 使用此依赖源码中引用了 <code>pdfast</code>, 重新单独 yarn add ‘依赖库’<br>一般出现<code>Could not resolve "xxx"</code> 大部分原因是依赖下载失败，就重新下载对应的依赖就行。</p><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><ul><li><p>会议列表进入会议按钮连续点击多次触发事件？<br>使用 lodash中的debounce（防抖函数）解决</p></li><li><p>引用第三方类库api时初始化方法多处需要使用？<br>onReady方法封装到全局函数中，使用到的地方直接使用全局函数</p></li><li><p>文件上传时接口报错404，排查原因后发现nginx默认的<em>传输字节</em>数大小默认是1M，当用户上传超过10kb内容后接口就报错<br>解决：nginx配置传输字节字段：client_max_body_size 500M</p></li><li><p>echarts实现中国地图，使用<code>geoJson</code>数据渲染；地图点击事件后返回地图信息中没有地图区域等级区分字段<br>手写整理各地区code、level集合；地图点击后拿到地区code去筛选拿到对应level</p></li><li><p>vue 使用 <code>keep-akive</code> 进行缓存组件时用到了计时器，但是被缓存的组件不会销毁，又想清除定时器 这时就用activated、deactivated两个生命周期去清除</p></li><li><p>vite打包部署服务器接口404 需要nginx配置代理！</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 配置接口 解决404</span>    location /api <span class="token punctuation">{</span>                proxy_set_header   Host             <span class="token variable">$host</span><span class="token punctuation">;</span>                proxy_set_header   x-forwarded-for  <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>                proxy_set_header   X-Real-IP        <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>                proxy_pass http://123.60.111.103:5000/api<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true"># 接口地址，如果在同一个服务器上，可以直接这样写</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三方库相关"><a href="#第三方库相关" class="headerlink" title="第三方库相关"></a>第三方库相关</h2><h3 id="高德地图使用遇到的问题"><a href="#高德地图使用遇到的问题" class="headerlink" title="高德地图使用遇到的问题"></a>高德地图使用遇到的问题</h3><ul><li><p>高德1.x版本和2.x版本踩坑</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// index.html 引入高德注意事项</span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://webapi.amap.com/maps?v=1.4.15&amp;key=xxx&amp;plugin=AMap.MarkerClusterer"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 2.0</span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://webapi.amap.com/maps?v=2.0&amp;key=xxx&amp;plugin=AMap.MarkerCluster"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>高德地图版本为 1.x 和 2.x。 两者部分api语法不同， 且插件名称 部分不同<br>  （2.0地图渲染比1.x快一些）<br>  如 点聚合插件：<br>  2.0:  AMap.MarkerCluster<br>  1.x:  AMap.MarkerClusterer</p></blockquote></li><li><p>高德地图点聚合2.0写法</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 初始化聚合点</span>  <span class="token keyword">function</span> initPointPolymerization <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pointsList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>pointsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>LNT<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> pointsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>LAT<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          state<span class="token punctuation">.</span>pointPolymerizationMarkers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              data<span class="token punctuation">:</span> pointsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 自定义的属性数据用于 非聚合点点击时获取</span>              lnglat<span class="token punctuation">:</span> <span class="token punctuation">[</span>pointsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>LNT<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pointsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>LAT<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 点聚合数据必须为此格式</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 聚合点自定义</span>  state<span class="token punctuation">.</span>cluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>MarkerCluster</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>map<span class="token punctuation">,</span> state<span class="token punctuation">.</span>pointPolymerizationMarkers<span class="token punctuation">,</span> <span class="token punctuation">{</span>      gridSize<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>      renderClusterMarker<span class="token punctuation">:</span> _renderClusterMarker<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 点聚合样式完全自定义</span>      renderMarker<span class="token punctuation">:</span> _renderMarker <span class="token comment" spellcheck="true">//  非聚合点样式设置， 点聚合缩放到最小的marker需要单独设置</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 设置聚合样式</span>  <span class="token keyword">function</span> _renderClusterMarker <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> countLength <span class="token operator">=</span> state<span class="token punctuation">.</span>pointPolymerizationMarkers<span class="token punctuation">.</span>length      <span class="token keyword">const</span> <span class="token punctuation">{</span> marker<span class="token punctuation">,</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> context      <span class="token keyword">let</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>      div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count      div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'markersClass1'</span> <span class="token comment" spellcheck="true">//添加class</span>      <span class="token keyword">let</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>count <span class="token operator">/</span> countLength<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">70</span><span class="token punctuation">)</span>      div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>      div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>lineHeight <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token string">'px'</span>      marker<span class="token punctuation">.</span><span class="token function">setOffset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Pixel</span><span class="token punctuation">(</span><span class="token operator">-</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      marker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 聚合点添加事件})</span>      marker<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 非聚合点样式 + click事件 必须在此函数添加</span>  <span class="token keyword">function</span> _renderMarker <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> dataArr <span class="token operator">=</span> context<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span> marker <span class="token punctuation">}</span> <span class="token operator">=</span> context      marker<span class="token punctuation">.</span><span class="token function">setExtData</span><span class="token punctuation">(</span>dataArr<span class="token punctuation">.</span>data<span class="token punctuation">)</span>      marker<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Icon</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      image<span class="token punctuation">:</span> markerIcon3<span class="token punctuation">,</span>      size<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Size</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      imageSize<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Size</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      marker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getExtData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// console.log('聚合点缩小最后为普通点-事件绑定', data)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 聚合点清除</span>  <span class="token keyword">function</span> pointPolymerizationMarkersDestroy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>pointPolymerizationMarkers<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          state<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span><span class="token function">setMap</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 清空cluster</span>          state<span class="token punctuation">.</span>pointPolymerizationMarkers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><ul><li>vue项目使用axios请求设置请求头为 <code>application/json;charset=utf-8;</code>结尾包含分号导致服务端node拿不到req.body的值</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>windows系统文件压缩zip后，其中中文图片乱码，导致编译时报错无法解析； mac系统则正常</li><li>h5应用接入浙里办，适老化。根据浙里办不同版本环境展示不同版本<br>一个项目两个版本路由，根据不同环境跳转不同路由。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts入门</title>
      <link href="/posts/4d03.html"/>
      <url>/posts/4d03.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是typeScript"><a href="#什么是typeScript" class="headerlink" title="什么是typeScript?"></a>什么是typeScript?</h1><p>官方网站的定义是:TypeScript 是 js 类型的超集。简单说你可以将 TypeScript 看作是 JavaScript 之上的一个外壳。<br>TypeScript 是一个外壳，因为编写 TypeScript 的代码，在编译之后，，剩下的只是简单的 js 代码。<br>但是 JS 引擎无法读取 TypeScript 代码，因此任何 TypeScript 文件都应该经过预翻译过程，即编译。只有在第一个编译步骤之后，才剩下纯 JS 代码，可以在浏览器中运行。<br>Ps: 浏览器只能运行js、无法直接运行ts，因此需要ts编译js后运行。</p><pre class="line-numbers language-bash"><code class="language-bash">全局安装<span class="token function">npm</span> i -g typescript查看版本tsc -v运行tstsc xxx.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开发运行环境"><a href="#开发运行环境" class="headerlink" title="开发运行环境"></a>开发运行环境</h2><p><strong>因为ts代码不能直接在node里运行 需要先编译为js再执行</strong></p><ul><li>运行方式1：<pre class="line-numbers language-bash"><code class="language-bash">tsc  a.ts  <span class="token operator">=</span><span class="token operator">></span> 编译为 a.jsnode  a.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>运行方式2：<br>如上操作每次执行很麻烦，  (这个依赖包会在内部把ts编译为js，不再输出js文件)<pre class="line-numbers language-bash"><code class="language-bash">全局安装<span class="token function">npm</span> i -g ts-node查看版本好ts-node -v直接运行ts-node xxx.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vscode里配置自动编译ts为js"><a href="#vscode里配置自动编译ts为js" class="headerlink" title="vscode里配置自动编译ts为js"></a>vscode里配置自动编译ts为js</h2>vsCode  新建ts文件 –&gt; ts文件目录cmd，初始化 tsc –init，生成一个tsconfig.json文件 –&gt; 修改tsconfig.json文件的 “outDir”: “./js”,  ./js为要生成的文件夹 –&gt;点击vsCode终端 》点击运行任务》点击选择typescript 》点击选择监视typescript </li></ul><p>好处：没事修改ts文件不会像方法一每次在控制台输入tsc index.js，这个是自动的方式<br>tsc –init  生成配置文件 做以下修改</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">"outDir": "./js" // 把ts编译后放js文件夹下"strict": false //改为不严格模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该目录终端-运行任务-所有任务-tsc监视  <strong>ps:这里目录不能有&amp;符号会报错</strong><br>修改配置文件后执行指定文件 tsc 不生效。 要执行tsc</p><h2 id="ts里的一些概念"><a href="#ts里的一些概念" class="headerlink" title="ts里的一些概念"></a>ts里的一些概念</h2><ul><li><p>类型注解？<br><strong>是一种轻量级的为函数或者变量添加的约束</strong></p><pre class="line-numbers language-javaScript"><code class="language-javaScript">function test (str: string) {return 'hell------' + str}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>隐式类型推断？</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">let age = 18 //   我们赋值变量数字18， 那么这个变量ts会推断为number类型// age ='qweq'   // 语法不允许let name // 如，我们声明变量name 没有赋值，ts无法推断当前变量类型 默认为any类型name = 18name = true// ps: 虽然ts会做隐式类型推断， 但是建议为每个变量明确类型，便于后期更直观的理解代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类型断言？<br><strong>在有些特殊情况下，ts无法推断出一个变量的具体类型，而我们开发者根据代码的使用情况知道这个变量到底什么类型的。从而辅助ts更加明确代码中每个成员的类型。</strong><br><strong>!!!重点!!!类型断言并不是类型转换，类型转换是代码运行时的概念，类型断言是编译过程中的概念， 编译后这个断言也就不存在了</strong></p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const nums = [1, 2, 4]const res = nums.find(i => i > 0)//此时res类型可能是number 或者 undefined 所以要使用断言指定类型// 断言写法:// as 关键字const num1 = res as number// jsx时不能使用 有语法冲突const num2 = <number>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类型声明？<br><strong>在实际开发中  ts中引入第三方模块，有的不是那ts写的， 就没有强类型的提示体验！！！</strong><br><strong>在使用第三方库过程中，如果当前模块不包含类型声明文件， 我们可以尝试安装对应模块的类型声明模块（一般为：＠types/…/）， 如果没有的话我们只能使用declare语法进行类型声明。 具体使用查看官方文档</strong></p></li></ul><h2 id="ts基础类型"><a href="#ts基础类型" class="headerlink" title="ts基础类型"></a>ts基础类型</h2><h3 id="一、原始类型7个"><a href="#一、原始类型7个" class="headerlink" title="一、原始类型7个"></a>一、原始类型7个</h3><pre class="line-numbers language-javaScript"><code class="language-javaScript"> const a: string = '123' const b: number = 123 const c: boolean = true const d: null = null const e: undefined = undefined const f: void = undefined const g: symbol = Symbol('123') console.log(a, b, c, d, e, f, g)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、其他类型"><a href="#二、其他类型" class="headerlink" title="二、其他类型"></a>二、其他类型</h3><h4 id="1-Object类型"><a href="#1-Object类型" class="headerlink" title="1.Object类型"></a>1.Object类型</h4><p>  不是单指普通的对象，可以是对象 数组  fun<br>  <code>const foo: object = {}  // []  // function() { }</code></p><h4 id="2-Array类型"><a href="#2-Array类型" class="headerlink" title="2.Array类型"></a>2.Array类型</h4><p>  <code>const arr1: number[] = [1, 2, 3]</code><br>  <code>const arr2: Array&lt;number&gt; = [1, 2, 3] // 泛型写法</code></p><h4 id="3-元组类型"><a href="#3-元组类型" class="headerlink" title="3.元组类型"></a>3.元组类型</h4><p>  明确元素数量以及元素类型的数组<br>  <code>const tuple: [number, string] = [2, '2']</code></p><h4 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4. 枚举类型"></a>4. 枚举类型</h4><p>  特点：给有一组数值给上更好理解的名字，一个枚举中只会出现固定的几个值不会出现超出范围的可能性</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  enum postState {  draft = 0, // 值可以不指定， 默认从0累加。 如果初始化值是 字符串 必须手动给每个成员指定值 -不常见。  unpublished = 1  }  // 常量枚举  const enum postState2 {  draft = 0,  unpublished = 1  }  // 使用  const obj = {  title: '',  state: postState.draft, // 0 1 2  state1: postState[0] // 可以使用索引值访问，  }  // ps:我们在ts中使用的大部分类型经过编译转换后都会被移除掉，因为他只是为了我们在编译过程中做类型检查！而枚举不会，枚举会影响我们编译后的结果，他最终编译成一个双向的键值对对象：其实就是可以用键获取值 用值获取键。  // 如果确认我们代码中不会使用索引值方式获取枚举值 我们建议使用常量枚举，enum前面添加const。使用常量枚举，编译后枚举会被移除掉。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-函数类型"><a href="#5-函数类型" class="headerlink" title="5.函数类型"></a>5.函数类型</h4><p>  // 定义分为：1声明函数， 2函数表达式</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  // d参数可选， 必须放最后  // rest任意个数参数使用es6的  function func1 (a: number, b: number, d?: number, ...rest: number[]): string {  return 'func1'  }  func1(1, 2)  // 函数表达式，接收这个函数的变量也需要类型注解  vscode会推断出这个变量类型 (a: number, b: number) => string  const func2: (a: number, b: number) => string = function (a: number, b: number) {  return 'func2'  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-任意类型any"><a href="#6-任意类型any" class="headerlink" title="6.任意类型any"></a>6.任意类型any</h4><p>  属于动态类型，ts不会对any做类型检查， 兼容js老代码时需要any类型</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  function func3 (val: any) {  return JSON.stringify(val)  // stringify方法接收任意类型参数  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-接口类型-interface"><a href="#7-接口类型-interface" class="headerlink" title="7.接口类型-interface"></a>7.接口类型-interface</h4><p>  一种规范契约，可以用来约定对象的结构，我们使用一个接口就必须遵守这个接口的全部约定。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  interface userFace {    age: number,    name: string,    title?: string // 可选成员    readonly content?: string // 只读成员,初始化后不可改变  }  // 参数user使用接口  function getUser (user: userFace) {    return user.age + user.name  }  console.log(getUser({ age: 18, name: 's' }))  // 动态接口写法：  interface userFace2 {    [key: string]: string // key代表属性名称任意名称string代表可以的类型， 第二个string代表键值的类型  }  const cache: userFace2 = {}  cache.foo = 'val1'  cache.bar = 'val2'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8.泛型"></a>8.泛型</h4><p>  把我们定义时不明确的类型变成一个参数 ，使用时在传递这样的类型参数！</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  function createNumberArray (length: number, value: number) {    // 因为Array对象默认创建是的any类型，所以我们要指定下他默认的类型  使用泛型指定    // const arr = Array(length).fill(value)    const arr = Array<number>(length).fill(value)    return arr  }  const rest = createNumberArray(3, 100)  console.log(rest)  // ps:此时 createNumberArray函数只能创建数字类型的数组。 如果还想创建字符串类型的数组 就可以使用泛型参数，  // ！！！！！！泛型参数方法  改进 createNumberArray！！！！  // 一般泛型参数为T ，然后把函数中不明确的参数类型都改为T  function createArray<T> (length: number, value: T) {    const arr = Array<T>(length).fill(value)    return arr  }  // 泛型使用  const rest2 = createArray<string>(3, 'foo')  console.log(rest2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-node多服务启动</title>
      <link href="/posts/e22d.html"/>
      <url>/posts/e22d.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue项目-nodejs服务，如何前后端服务同时启动？"><a href="#vue项目-nodejs服务，如何前后端服务同时启动？" class="headerlink" title="vue项目+nodejs服务，如何前后端服务同时启动？"></a>vue项目+nodejs服务，如何前后端服务同时启动？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时我们在vue项目里使用了Nodejs 提供接口服务时，这时就需要执行node服务命令和前端项目服务。那有没有同时跑前端和后端的服务方法呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用 concurrently 并行地运行多个命令。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> concurrentlyoryarn add concurrently<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后更改 package.json 文件，scripts如下：</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">"scripts": {  "start": "craco start",  "build": "scraco build",  "test": "craco test",  "eject": "react-scripts eject",  "node": "npm run serve --prefix nodeServer",  "dev": "concurrently npm:node yarn:start"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了 –prefix nodeServer 就不用 cd nodeServer 文件夹了，也就是说运行 <strong>npm run node</strong> 就会跑后端的服务，相当于：<strong>npm run serve</strong><br>此时只需要<strong>npm run dev</strong> 就会执行 <strong>npm run node</strong> 和 <strong>npm run start</strong>  也就实现了同时启动了服务端和客户端。<br>ps:这里命令我有用了yarn也是可以的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue+node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/posts/9cde.html"/>
      <url>/posts/9cde.html</url>
      
        <content type="html"><![CDATA[<h1 id="vim是什么？"><a href="#vim是什么？" class="headerlink" title="vim是什么？"></a>vim是什么？</h1><p>vim/vi是Unix / Linux上最常用的文本编辑器而且功能非常强大。但是【只有命令，没有菜单。】</p><h1 id="Vscode-vim使用："><a href="#Vscode-vim使用：" class="headerlink" title="Vscode vim使用："></a>Vscode vim使用：</h1><p>y复制（先选中）<br>yy复制一行<br>nyy复制多行（n为行数）<br>p粘贴<br>u撤销<br>移动光标至所选行的开头，按v进入视图，键盘上按向下键，选中所需行即可。<br>恢复刚才的操做 ctrl+r<br>v+w 打开选中模式，并向后移动一个单词<br>v+b 打开选中模型，并向前移动一个单词<br>v+i+w 打开选中模式，并选中当前单词</p><h1 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h1><h2 id="一、默认normal模式"><a href="#一、默认normal模式" class="headerlink" title="一、默认normal模式"></a>一、默认normal模式</h2><p>  正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一般的键/键组合会被当成功能键，而不会键入对应的字符。在这个模式下，我们可能通过键盘在文本中跳来跳去，跳动的范围从小到大是字符、单词、行、句子、段落和屏幕。启动vim后默认位于正常模式。不论位于什么模式，按下<esc>键(有时需要按两下）都会进入正常模式。</esc></p><ul><li><p>移动<br><font color="red">单词操作:</font><br>w=  word 跳到下一个单词的开头<br>e=  跳到下一个单词的结尾<br>b=  back word 跳到上一个单词的开头<br><font color="red">行操作:</font><br>0行首<br>I单词行首<br>$ 行尾<br>A单词行尾<br>15gg跳转到15行<br>:18 = 进入18行<br>18G =进入18行<br>gg文件首行<br>G文件末行<br>Shift + [] 是以「代码块」为单位跳行<br>Ctrl + u 和 Ctrl + d 实现上下滚动页面，滚动行数默认为半页大小<br>[[ 跳到文件首行，而 ]] 则是行末。<br>gd: 函数的跳转 go to defined<br>ctr+o 退出到原先的函数位置<br>当前行下移一行 :m+<br>当前行上移一行 :m-2</p></li><li><p>选中<br>v+i+w      放在一个单词的任意位置时均可选中本单词<br>v+e      光标放在一个单词的开头时可选中本单词<br>v+h/j/k/l      进入视图模式后使用方向键容易选中你想选的部分</p></li><li><p>增<br>d = delete 删除 d是开启剪切模式<br>x= 删除一个字符<br>dG = 删除全部<br>3x = 3个字符<br>dd= 剪切一行/ndd删除n是数字<br>dw = delete word 删除一个单词-光标在单词位置<br>diw = delete inner word 删除一个单词进入插入模式<br>daw = delete around word 包含空格<br>s是删除当前光标所指并转为 insert 模式</p></li><li><p>改<br>c= change<br>cc= 删除一行并且进入写入模式<br>ciw=删除一个单词并进入插入模式<br>ct) = 光标不在括号内，修改到右括号，<br>ct) =光标在括号内容第一个字符，删除()内容进入插入模式<br>以下命令可以对标点内的内容进行操作。<br>ci’、ci”、ci(、ci[、ci{、ci&lt; - 分别更改这些配对标点符号中的文本内容<br>di’、di”、di(或dib、di[、di{或diB、di&lt; - 分别删除这些配对标点符号中的文本内容<br>yi’、yi”、yi(、yi[、yi{、yi&lt; - 分别复制这些配对标点符号中的文本内容<br>vi’、vi”、vi(、vi[、vi{、vi&lt; - 分别选中这些配对标点符号中的文本内容</p></li><li><p>查</p></li><li><ul><li>查找<br>查找’name’: <code>/name</code>  n向下 N向上<br>取消查找高亮命令: <code>:nohl</code><br>在normal模式下按下*即可查找光标所在单词<br>在查找模式中加入\c表示大小写不敏感查找，\C表示大小写敏感查找。<br>例如：<code>/foo\c</code> 将会查找所有的”foo”,”FOO”,”Foo”等字符串。</li></ul></li><li><ul><li>查找替换<br>:s（substitute）命令用来查找和替换字符串<br>例如:<code>%s/foo/bar/g</code> 会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）<br>g即是替换标志之一，如： i表示大小写不敏感查找，I表示大小写敏感。<br>还有空替换标志表示只替换从光标位置开始，目标的第一次出现：<br><code>:%s/foo/bar</code></li></ul><p>作用范围分为当前行、全文、选区等等。<br>当前行：<br><code>:s/foo/bar/g</code><br>全文：<br><code>:%s/foo/bar/g</code><br>选区，在Visual模式下选择区域后输入:，Vim即可自动补全为 :’&lt;,’&gt;。<br><code>:'&lt;,'&gt;s/foo/bar/g</code><br>2-11行：<br><code>:5,12s/foo/bar/g</code><br>当前行.与接下来两行+2：<br><code>:.,+2s/foo/bar/g</code></p><h2 id="二、insert插入模式"><a href="#二、insert插入模式" class="headerlink" title="二、insert插入模式"></a>二、insert插入模式</h2><p>在正常模式中按下i, I, a, A等键，会进入插入模式。<br>小写包含空格，大写不包含空格<br>a/A = append： 后面插入<br>i /I = insert :前面插入<br>o/O = open a line ：另起一行<br>现在只用记住按i键会进行插入模式。插入模式中，击键时会写入相应的字符。</p><h2 id="三、visual可视模式"><a href="#三、visual可视模式" class="headerlink" title="三、visual可视模式"></a>三、visual可视模式</h2><p>在正常模式按下v, V, <ctrl>+v，可以进入可视模式。可视模式中的<br>操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</ctrl></p><p>i(  =会选中括号里面的单词<br>i”  = 会选中””引号里内容<br>a(  =会选中括弧以及括弧里面的单词<br>a”  =会选中””和内容<br>aw  =会选中单词以及单词前面的一个空格<br>iw  = 会选中一个单词 (visual模式)</p><h2 id="四、command命令模式"><a href="#四、command命令模式" class="headerlink" title="四、command命令模式"></a>四、command命令模式</h2></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用方法、</title>
      <link href="/posts/7a45.html"/>
      <url>/posts/7a45.html</url>
      
        <content type="html"><![CDATA[<h2 id="记录js常用方法"><a href="#记录js常用方法" class="headerlink" title="记录js常用方法"></a>记录js常用方法</h2><h2 id="js类型判断"><a href="#js类型判断" class="headerlink" title="js类型判断"></a>js类型判断</h2><ul><li>Object.prototype.toString<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 以下是11种：</span><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// [object Number]</span><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// [object String]</span><span class="token keyword">var</span> boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// [object Boolean]</span><span class="token keyword">var</span> und <span class="token operator">=</span> undefined<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// [object Undefined]</span><span class="token keyword">var</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// [object Null]</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// [object Object]</span><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [object Array]</span><span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [object Date]</span><span class="token keyword">var</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Error]</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a/g</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// [object RegExp]</span><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Function]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>function checkType() {<br>    for (var i = 0; i &lt; arguments.length; i++) {<br>        console.log(Object.prototype.toString.call(arguments[i]))<br>    }<br>}</p><p>checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)</p><pre><code>## Object对象* Object.defineProperty(obj,prop,descriptor)  vue2.0数据劫持就是使用此方法* hasOwnProperty()  &gt; 判断对象自身属性中是否具有指定的属性。  obj.hasOwnProperty('name')* Object.is()  &gt; 判断两个值是否相对返回布尔值* Object.keys()、Object.values()  &gt; 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in循环枚举原型链中的属性 )* Object.freeze()  &gt; 冻结一个对象，阻止修改现有属性特性的值，并阻止添加新属性* Object.assign(target,source1,source2,...)  对象合并## 数组* slice()  截取数组，不改变原数组* splice() 更新数组，改变原数组* forEach()、map()、filter()、some()、every() 迭代方法，不改变原数组* every&gt; arr.every((currentValue , index , arr) =&gt; {}, thisValue) 判断数组中的每一项是否都满足条件，全部符合就会返回true，否则false。```javascriptconst arr = [1, 2, 3]const str = arr.every((currentValue) =&gt; {    return currentValue &gt; 1})console.log(str) // false</code></pre><ul><li>some<blockquote><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true，不再往下执行</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript">arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>currentValue <span class="token punctuation">,</span> index <span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> thisValue<span class="token punctuation">)</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">const</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">)</span>  <span class="token keyword">return</span> currentValue <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>keys()、values()、entries() 遍历数组方法,不改变原数组。 （es6新增方法）<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//打印：</span><span class="token comment" spellcheck="true">// [0, "a"]</span><span class="token comment" spellcheck="true">// [1, "b"]</span><span class="token comment" spellcheck="true">// [2, "c"]</span><span class="token comment" spellcheck="true">// [3, "d"]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>idx<span class="token punctuation">,</span>item<span class="token punctuation">]</span> <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token string">":"</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//打印：</span><span class="token comment" spellcheck="true">// 0:a</span><span class="token comment" spellcheck="true">// 1:b</span><span class="token comment" spellcheck="true">// 2:c</span><span class="token comment" spellcheck="true">// 3:d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre><code>*  Array.from() （es6新增方法）&gt; Array.from() 用于类似数组的对象（即有length属性的对象）和可遍历对象转为真正的数组。```javascript  const json ={    '0':'喜',    '1':'欢',    '2':'你',    length:3}const arr = Array.from(json)console.log(arr) // ["喜", "欢", "你"]</code></pre><ul><li><p>includes() 不改变原数组。 （es6新增方法）</p><blockquote><p>arr.includes(searchElement , fromIndex) 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token keyword">const</span> result1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token keyword">const</span> result2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> result3 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> result4 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// flase</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result4<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>reduce()、reduceRight() 归并方法，不改变原数组<br>这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数，第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组，函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。<br>[total] 必须项，初始值, 或者计算结束后的返回值。<br>[cur] 必须项，当前元素。<br>[index] 可选。当前元素的索引值<br>[arr] 可选。当前元素所属的数组对象<br>[initialValue] 可选。传递给函数的初始值。</p><blockquote><p>arr.reduce((total , cur , index , arr) =&gt; {}, initialValue) 从数组的第一项开始，逐个遍历到最后<br>arr.reduceRight((total , cur , index , arr) =&gt; {}, initialValue) 从数组的最后一项开始，向前遍历到第一项</p></blockquote></li></ul><h2 id="ES2017-ES8"><a href="#ES2017-ES8" class="headerlink" title="ES2017(ES8)"></a>ES2017(ES8)</h2><ul><li>Object.entries() 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。</li></ul><pre class="line-numbers language-javaScript"><code class="language-javaScript">  const obj = {  name: "jimmy",  age: 18,  height: 188,};console.log(Object.entries(obj)); // [ [ 'name', 'jimmy' ], [ 'age', 18 ], [ 'height', 188 ] ]console.log(Object.entries([1, 2, 3])); // [ [ '0', 1 ], [ '1', 2 ], [ '2', 3 ] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>String.prototype.padStart<br>把指定字符串填充到字符串头部，返回新字符串。<pre class="line-numbers language-javaScript"><code class="language-javaScript">'abc'.padStart(10);         // "       abc"'abc'.padStart(10, "foo");  // "foofoofabc"'abc'.padStart(6,"123465"); // "123abc"'abc'.padStart(8, "0");     // "00000abc"'abc'.padStart(1);          // "abc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>// 应用场景：<br>// 数字替换(手机号，银行卡号等）<br>const tel = ‘18781268679’<br>const newTel = tel.slice(-4).padStart(tel.length, ‘<em>‘)<br>console.log(newTel) // <strong>**</strong></em>5678</p><pre><code>## ES2018(ES9)* Object RestObject rest 的示例：```javaScriptconst input = {  a: 1,  b: 2,  c: 3}let { a, ...rest } = inputconsole.log(a, rest) // 1 {b: 2, c: 3}// 当对象 key-value 不确定的时候，把必选的 key 赋值给变量，用一个变量收敛其他可选的 key 数据，这在之前是做不到的。注意，rest 属性必须始终出现在对象的末尾，否则将抛出错误。</code></pre><ul><li>for await of<br>异步迭代器(for-await-of)：循环等待每个Promise对象变为resolved状态才进入下一步。</li></ul><p>我们知道 for…of 是同步运行的，看如下代码</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">function TimeOut(time){    return new Promise(function(resolve, reject) {        setTimeout(function() {            resolve(time)        }, time)    })}async function test() {    let arr = [TimeOut(2000), TimeOut(1000), TimeOut(3000)]    for (let item of arr) {       console.log(Date.now(),item.then(console.log))    }}test()// 上述代码证实了 for of 方法不能遍历异步迭代器，得到的结果并不是我们所期待的，于是 for await of 就粉墨登场啦！// ES9 中可以用 for...await...of 的语法来操作function TimeOut(time) {    return new Promise(function(resolve, reject) {        setTimeout(function() {            resolve(time)        }, time)    })}async function test() {    let arr = [TimeOut(2000), TimeOut(1000), TimeOut(3000)]    for await (let item of arr) {        console.log(Date.now(), item)    }}test()// 1560092345730 2000// 1560092345730 1000// 1560092346336 3000// for await of 环等待每个Promise对象变为resolved状态才进入下一步。所有打印的结果为 2000，1000，3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Promise.prototype.finally()<br>Promise.prototype.finally() 方法返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行finally指定的回调函数。这为指定执行完promise后，无论结果是fulfilled还是rejected都需要执行的代码提供了一种方式，避免同样的语句需要在then()和catch()中各写一次的情况。<pre class="line-numbers language-javaScript"><code class="language-javaScript">new Promise((resolve, reject) => {  setTimeout(() => {      resolve('success')      // reject('fail')  }, 1000)}).then(res => {  console.log(res)}).catch(err => {  console.log(err)}).finally(() => {  console.log('finally')})// 使用场景// loading关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>// 需要每次发送请求，都会有loading提示，请求发送完毕，就需要关闭loading提示框，不然界面就无法被点击。不管请求成功或是失败，这个loading都需要关闭掉，这时把关闭loading的代码写在finally里再合适不过了</p><pre><code>## ES2019(ES10)*Object.fromEntries()方法 Object.fromEntries() 把键值对列表转换为一个对象，这个方法是和 Object.entries() 相对的。```javaScriptObject.fromEntries([    ['foo', 1],    ['bar', 2]])// {foo: 1, bar: 2}// 案例1：Object 转换操作const obj = {    name: 'jimmy',    age: 18}const entries = Object.entries(obj)console.log(entries)// [Array(2), Array(2)]// ES10const fromEntries = Object.fromEntries(entries)console.log(fromEntries)// {name: "jimmy", age: 18}// 案例2：Map 转 Objectconst map = new Map()map.set('name', 'jimmy')map.set('age', 18)console.log(map) // {'name' =&gt; 'jimmy', 'age' =&gt; 18}const obj = Object.fromEntries(map)console.log(obj)// {name: "jimmy", age: 18}// 案例3：过滤// course表示所有课程，想请求课程分数大于80的课程组成的对象：const course = {    math: 80,    english: 85,    chinese: 90}const res = Object.entries(course).filter(([key, val]) =&gt; val &gt; 80)console.log(res) // [ [ 'english', 85 ], [ 'chinese', 90 ] ]console.log(Object.fromEntries(res)) // { english: 85, chinese: 90 }// 案例4：url的search参数转换// let url = "https://www.baidu.com?name=jimmy&amp;age=18&amp;height=1.88"// queryString 为 window.location.searchconst queryString = "?name=jimmy&amp;age=18&amp;height=1.88";const queryParams = new URLSearchParams(queryString);const paramObj = Object.fromEntries(queryParams);console.log(paramObj); // { name: 'jimmy', age: '18', height: '1.88' }</code></pre><p>*Array.prototype.flat()<br>let newArray = arr.flat([depth])<br>depth 可选  指定要提取嵌套数组的结构深度，默认值为 1。<br>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const arr1 = [0, 1, 2, [3, 4]];console.log(arr1.flat());  //  [0, 1, 2, 3, 4]const arr2 = [0, 1, 2, [[[3, 4]]]];console.log(arr2.flat(2));  //  [0, 1, 2, [3, 4]]//使用 Infinity，可展开任意深度的嵌套数组var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];arr4.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// `flat()` 方法会移除数组中的空项:var arr5 = [1, 2, , 4, 5];arr5.flat(); // [1, 2, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*Array.prototype.flatMap()<br>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。从方法的名字上也可以看出来它包含两部分功能一个是 map，一个是 flat（深度为1）。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const numbers = [1, 2, 3]numbers.map(x => [x * 2]) // [[2], [4], [6]]numbers.flatMap(x => [x * 2]) // [2, 4, 6]// 这个示例可以简单对比下 map 和 flatMap 的区别。当然还可以看下下面的示例：let arr = ['今天天气不错', '', '早上好']arr.map(s => s.split(''))// [["今", "天", "天", "气", "不", "错"],[""],["早", "上", "好"]]arr.flatMap(s => s.split(''))// ["今", "天", "天", "气", "不", "错", "", "早", "上", "好"]// flatMap 方法与 map 方法和深度depth为1的 flat 几乎相同.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*String.prototype.trimStart()<br>trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">let str = '   foo  'console.log(str.length) // 8str = str.trimStart() // 或str.trimLeft()console.log(str.length) // 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*可选的Catch Binding<br>在 ES10 之前我们都是这样捕获异常的：</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">try {    // tryCode} catch (err) {    // catchCode}// 在这里 err 是必须的参数，在 ES10 可以省略这个参数：try {    console.log('Foobar')} catch {    console.error('Bar')}// 应用// 验证参数是否为json格式// 这个需求我们只需要返回true或false，并不关心catch的参数。const validJSON = json => {    try {        JSON.parse(json)        return true    } catch {        return false    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ES2020-ES11"><a href="#ES2020-ES11" class="headerlink" title="ES2020(ES11)"></a>ES2020(ES11)</h2><p>*可选链操作符( ?. )<br>?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为 null 或者 undefined 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。<br>*空值合并运算符（Nullish coalescing Operator）<br>空值合并操作符（ ?? ）是一个逻辑操作符，当左侧的操作数为 null或者undefined时，返回其右侧操作数，否则返回左侧操作数。</p><pre class="line-numbers language-js"><code class="language-js">与空值合并操作符一起使用<span class="token keyword">let</span> customer <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"jimmy"</span><span class="token punctuation">,</span>  details<span class="token punctuation">:</span> <span class="token punctuation">{</span> age<span class="token punctuation">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> customerCity <span class="token operator">=</span> customer<span class="token operator">?</span><span class="token punctuation">.</span>city <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"成都"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>customerCity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "成都"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javaScript"><code class="language-javaScript">const foo = undefined ?? "foo"const bar = null ?? "bar"console.log(foo) // fooconsole.log(bar) // bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*Promise.allSettled()<br>我们都知道 Promise.all() 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject 状态。</p><p>场景：现在页面上有三个请求，分别请求不同的数据，如果一个接口服务异常，整个都是失败的，都无法渲染出数据</p><p>我们需要一种机制，如果并发任务中，无论一个任务正常或者异常，都会返回对应的的状态，这就是Promise.allSettled的作用</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const promise1 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("promise1");      //   reject("error promise1 ");    }, 3000);  });};const promise2 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("promise2");      //   reject("error promise2 ");    }, 1000);  });};const promise3 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      //   resolve("promise3");      reject("error promise3 ");    }, 2000);  });};//  Promise.all 会走到catch里面Promise.all([promise1(), promise2(), promise3()])  .then((res) => {    console.log(res);   })  .catch((error) => {    console.log("error", error); // error promise3   });// Promise.allSettled 不管有没有错误，三个的状态都会返回Promise.allSettled([promise1(), promise2(), promise3()])  .then((res) => {    console.log(res);      // 打印结果     // [    //    {status: 'fulfilled', value: 'promise1'},     //    {status: 'fulfilled',value: 'promise2'},    //    {status: 'rejected', reason: 'error promise3 '}    // ]  })  .catch((error) => {    console.log("error", error);   });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*import()可以在需要的时候，再加载某个模块。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">button.addEventListener('click', event => {  import('./dialogBox.js')  .then(dialogBox => {    dialogBox.open();  })  .catch(error => {    /* Error handling */  })});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ES2021-ES12"><a href="#ES2021-ES12" class="headerlink" title="ES2021(ES12)"></a>ES2021(ES12)</h2><p>*&amp;&amp;=</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">// 逻辑与赋值 x &&= y等效于：x && (x = y);// 上面的意思是，当x为真时，x=y。// 具体请看下面的示例:let a = 1;let b = 0;a &&= 2;console.log(a); // 2b &&= 2;console.log(b);  // 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*||=</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">逻辑或赋值（x ||= y）运算仅在 x 为false时赋值。x ||= y 等同于：  x || (x = y);const a = { duration: 50, title: '' };a.duration ||= 10;console.log(a.duration); // 50a.title ||= 'title is empty.';console.log(a.title); // "title is empty"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*??=</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">逻辑空赋值运算符 (x ??= y) 仅在 x 是 nullish[3] (null 或 undefined) 时对其赋值。x ??= y 等价于：x ?? (x = y);const a = { duration: 50 };a.duration ??= 10;console.log(a.duration); // 50a.speed ??= 25;console.log(a.speed); // 25function config(options) {  options.duration ??= 100;  options.speed ??= 25;  return options;}config({ duration: 125 }); // { duration: 125, speed: 25 }config({}); // { duration: 100, speed: 25 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*String.prototype.replaceAll()<br>replaceAll()  方法返回一个新字符串，新字符串中所有满足 pattern 的部分都会被replacement 替换。pattern可以是一个字符串或一个RegExp，replacement可以是一个字符串或一个在每次匹配被调用的函数。</p><p>原始字符串保持不变。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">'aabbcc'.replaceAll('b', '.'); // 'aa..cc'// 使用正则表达式搜索值时，它必须是全局的。// 'aabbcc'.replaceAll(/b/, '.');// TypeError: replaceAll must be called with a global RegExp这将可以正常运行:'aabbcc'.replaceAll(/b/g, '.');"aa..cc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*Promise.any<br>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">const promise1 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("promise1");      //  reject("error promise1 ");    }, 3000);  });};const promise2 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("promise2");      // reject("error promise2 ");    }, 1000);  });};const promise3 = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("promise3");      // reject("error promise3 ");    }, 2000);  });};Promise.any([promise1(), promise2(), promise3()])  .then((first) => {    // 只要有一个请求成功 就会返回第一个请求成功的    console.log(first); // 会返回promise2  })  .catch((error) => {    // 所有三个全部请求失败 才会来到这里    console.log("error", error);  });只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- *```javaScript``` --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础</title>
      <link href="/posts/f82e.html"/>
      <url>/posts/f82e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Markdown？"><a href="#什么是Markdown？" class="headerlink" title="什么是Markdown？"></a>什么是Markdown？</h1><p>Markdown 设计灵感主要来源于纯文本电子邮件的格式，目标是让人们能够使用易读、易写的纯文本格式编写文档，而且这些文档可以转换为 HTML（Hyper Text Markup Language，超文本标记语言）文档。</p><p>简单来说，Markdown 是由一些简单的符号（如*/-&gt;[]()#）组成的用于排版的标记语言，其最重要的特点就是可读性强。</p><p>Markdown 相当于简化了的 HTML，它只提供用户最常用的语法格式，更易读和易写，用户可以不必关心复杂的 HTML 标签，只专注于写作就行了。</p><p>常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><h1 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h1><p>直接创建，没啥限制和要求。<br>排版简单，可读、直观、学习成本低<br>支持插入图片，视频等等（根据平台不同而定）<br>轻松的导出 HTML、.md 文件<br>可跨平台同步数据<br>随时可修改（不必像word等易混乱）</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code>一级标题对应一个 # 号；二级标题对应两个 # 号；以此类推。。。一共六级标题。</code></pre><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><pre><code>&lt;font face="黑体" color=green size=5&gt;黑体，绿色，尺寸为5（任意内容）&lt;/font&gt;or$\color{red}{红色字}$</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code>[name:大话卷积神经网络CNN（title:干货满满）](url:https://blog.csdn.net/TeFuirnever/article/details/100057229)or&lt;https://blog.csdn.net/TeFuirnever/article/details/100057229&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![图片描述](图片地址)支持 jpg、png、gif、svg 等图片格式，其中 svg 文件仅可在微信公众平台中使用。</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><pre><code>单行代码：代码之间分别用一个反引号包起来即可Use the `printf()` function.代码块高亮：``` key  支持多种语言 js java bash ....代码块```</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code>可以在一行中用3个 - 或者 * 来建立一个分隔线，同时需要在分隔线的上面空一行，如下：---或者**** * ******- - -</code></pre><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><pre><code>删除线的使用，在需要删除的文字前后各使用两个 ~~~这是要被删除的内容。~~</code></pre><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><pre><code>下划线的使用，在需要添加下划线的文字首部和尾部加上 &lt;u&gt;文本&lt;/u&gt;，如下：&lt;u&gt;这行文字已被添加下划线&lt;/u&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmd\linux\git\vscode等相关常用命令</title>
      <link href="/posts/c9f9.html"/>
      <url>/posts/c9f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用终端命令"><a href="#常用终端命令" class="headerlink" title="常用终端命令"></a>常用终端命令</h1><h2 id="node版本管理工具nvm"><a href="#node版本管理工具nvm" class="headerlink" title="node版本管理工具nvm"></a>node版本管理工具nvm</h2><ul><li>nvm工具使用</li></ul><pre class="line-numbers language-js"><code class="language-js">nvm list available 显示所有可安装的node版本nvm install <span class="token number">14.17</span><span class="token punctuation">.</span><span class="token number">6</span> 下载指定版本nvm uninstall <span class="token operator">&lt;</span>version<span class="token operator">></span> ：卸载指定版本nodenvm use xxx 使用当前下载的某个版本nvm install stable 安装最新稳定版本nodenvm ls 查看已安装的node版本nvm current 查看当前版本nvm arch 显示node是运行在<span class="token number">32</span>位还是<span class="token number">64</span>位nvm on：开启node<span class="token punctuation">.</span>js版本管理。nvm off：关闭node<span class="token punctuation">.</span>js版本管理。nvm默认node镜像源是https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nodejs<span class="token punctuation">.</span>org<span class="token operator">/</span>dist，从默认的镜像缘源下载会很慢，所以可以通过更换镜像源加快下载where nvm 找到nvm安装路径找到settings<span class="token punctuation">.</span>txt文件将下面这两句话复制到settings<span class="token punctuation">.</span>txt<span class="token punctuation">,</span>并保存node_mirror<span class="token punctuation">:</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span class="token operator">/</span>mirrors<span class="token regex">/node/</span>npm_mirror<span class="token punctuation">:</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span class="token operator">/</span>mirrors<span class="token regex">/npm/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>yarn<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 查看安装的全局包</span>yarn global list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>yarn global bin // 全局安装目录<br>//这样才是安装到全局环境<br>yarn global add xxx</p><p>// yarn查看所有版本<br>npm view yarn versions<br>// yarn更新到最新版<br>npm install yarn@latest -g</p><pre><code>* 设置淘宝镜像```js// 查看全局包安装目录npm config get prefixnpm config set prefix "目录路径" 来设置npm config set registry http://registry.npm.taobao.org/// 设置yarn淘宝镜像yarn config set registry http://registry.npm.taobao.org/// 查询当前配置的镜像npm get registryyarn config get registry</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git其他"><a href="#git其他" class="headerlink" title="git其他"></a>git其他</h3><p>github浏览器快捷查看文件方式： github后面添加1s<br>地址栏直接  <a href="https://github.com/">https://github.com/</a> 修改为github1s.com</p><p>我的git-pages地址: <a href="https://silin001.github.io">https://silin001.github.io</a></p><p>git本地查找密钥：gitbash打开终端窗口：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> ~/.ssh<span class="token function">cat</span> id_rsa.pub 查看公钥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="git初始化"><a href="#git初始化" class="headerlink" title="git初始化"></a>git初始化</h3><ul><li>初始化<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> status<span class="token function">git</span> log  <span class="token comment" spellcheck="true"># 显示提交日志</span><span class="token function">git</span> config --global user.name <span class="token string">"xxx"</span>    <span class="token comment" spellcheck="true"># 配置用户名</span><span class="token function">git</span> config --global user.email <span class="token string">"xxx@xxx.com"</span>  <span class="token comment" spellcheck="true"># 配置邮件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre><code>* 本地创建 git 仓库?```bashmkdir xxxcd xxxgit inittouch README.md添加文件：git add README.mdgit commit -m "first commit"git remote add origin git@gitee.com:sisi001/xxx.gitgit push -u origin "main" （注意gitee 远程主分支是 master  github是main）</code></pre><ul><li>远程已有仓库?</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> existing_git_repo<span class="token function">git</span> remote add origin git@gitee.com:sisi001/xxx.git<span class="token function">git</span> push -u origin <span class="token string">"main"</span>  （注意gitee 远程主分支是 master  github是main）<span class="token comment" spellcheck="true"># git提交时报错：</span><span class="token comment" spellcheck="true">#Updates were rejected because the tip of your current branch is behind......解决方案</span><span class="token function">git</span> push -u origin master -f  <span class="token comment" spellcheck="true">#-f意为强制推送。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-push、git-pull"><a href="#git-push、git-pull" class="headerlink" title="git push、git pull"></a>git push、git pull</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone URL  <span class="token comment" spellcheck="true">#拉取远程代码到本地</span><span class="token function">git</span> commit -m <span class="token string">"提交内容"</span> <span class="token comment" spellcheck="true">#提交暂存区的更改，并记录下备注</span><span class="token function">git</span> push origin main  <span class="token comment" spellcheck="true">#将完成的项目推送到远程仓库中（注意github默认主分支为main，gitee为matser ）</span><span class="token function">git</span> push -u origin main <span class="token comment" spellcheck="true">#第一次提交， 加上 -f 强制推送</span><span class="token comment" spellcheck="true"># 更新</span><span class="token function">git</span> fetch<span class="token function">git</span> merge<span class="token function">git</span> pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>/<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span><span class="token comment" spellcheck="true">#从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge 拉去并且合并</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>git pull 的时候多次碰见下面的情况：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 错误信息：</span>There is no tracking information <span class="token keyword">for</span> the current branch.Please specify <span class="token function">which</span> branch you want to merge with.See git-pull<span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token keyword">for</span> details.<span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span>If you wish to <span class="token keyword">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">></span> release    <span class="token comment" spellcheck="true">#解决：git branch --set-upstream 本地关联远程分支</span>    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/remote_branch main    <span class="token comment" spellcheck="true">#其中，origin/remote_branch是你本地分支对应的远程分支； main是你当前的本地分支。</span><span class="token comment" spellcheck="true"># 然后就会提示这个错误信息：</span>fatal: branch <span class="token string">'main'</span> does not exist    <span class="token comment" spellcheck="true"># 出现这个问题原因就是本地没有 main 分支导致的。</span>    输入 <span class="token function">git</span> branch -a 发现只有远程分支。    解决方式就是：输入  <span class="token function">git</span> checkout master<span class="token comment" spellcheck="true"># 错误信息：</span>出现 Already on <span class="token string">'master'</span> ,Branch <span class="token string">'master'</span> <span class="token keyword">set</span> up to track remote branch <span class="token string">'master'</span> from <span class="token string">'origin'</span>.，说明已经切换到 master 上。    再次输入 <span class="token function">git</span> branch -a 发现已经有本地分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch ：查看本地分支<span class="token function">git</span> branch -r ：查看远程分支<span class="token function">git</span> branch -a ：查看本地和远程分支<span class="token function">git</span> branch 分支名字 ：新建本地分支<span class="token function">git</span> branch -d 分支名字 ：删除本地分支 （分支被合并后才允许删除 ，把 -d 改成 -D 强制删除）<span class="token function">git</span> branch -m 旧的分支名字 新的分支名字 ：重新命名分支<span class="token function">git</span> branch --merged：查看哪些分支已经合并到当前分支<span class="token function">git</span> branch --no-merged：查看当前哪些分支还没有合并到当前分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout --<span class="token operator">&lt;</span>file<span class="token operator">></span> ：撤销上一次对文件的操作<span class="token function">git</span> checkout  想要切换的分支名：从当前所处的分支切换到其他分支（当切换分支的时候，需要把暂存区里面的文件进行提交,不然暂存区里面的文件会跟着到切换的这条分支上<span class="token punctuation">)</span><span class="token function">git</span> checkout -b <span class="token operator">&lt;</span>branch-name<span class="token operator">></span>：新建并切换到新建分支上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><font color="red">ps: cmd和vscode终端部分操作不同！</font><h2 id="快速删除node-modules"><a href="#快速删除node-modules" class="headerlink" title="快速删除node_modules"></a>快速删除node_modules</h2><p>在项目目录下打开cmd ,使用rd /s /q node_modules 可以快速删除<br><code>rd /s /q node_modules</code><br>or<br>如果是powershell，使用rd -r node_modules命令<br><code>rd -r node_modules</code><br>or</p><pre class="line-numbers language-js"><code class="language-js">npm install rimraf <span class="token operator">-</span>grimraf node_modules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>dir -查看目录</p><h3 id="1、文件夹："><a href="#1、文件夹：" class="headerlink" title="1、文件夹："></a>1、文件夹：</h3><p>md  - 创建文件夹<br>rm - 只能删除空文件夹      /   cmd：rd 删除文件夹<br>rm /s  删整个文件夹  /q不提示</p><h3 id="2、文件："><a href="#2、文件：" class="headerlink" title="2、文件："></a>2、文件：</h3><p>del [filename] - 删除文件<br>首先是创建空文件，命令type nul&gt;[filename]<br>命令echo [fileContent]&gt;[filename] 向文件写入内容</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>rm -rf node_modules 快速删除node_modules<br>mkdir ‘’  创建目录<br>rm -r test 删除目录<br>touch ‘’ 创建文件<br>rm  文件名 删除<br>打开文件： vi　文件名　<br>退出打开的文件　　ｑ：　不报错强制　退出　ｑ！<br>搜索目录【查】find<br>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 终端命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd、git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
